[{"title":"Python PIL库安装","date":"2017-07-05T08:01:16.000Z","path":"2017/07/05/Python pIL库安装/","text":"由于需要使用Python操作图片，想使用sudo pip install PIL引入PIL(Python Imaging Library)库，但是结果如下： 12could not find a version that satisfies the requirement PIL.(form versions:)No matching distribution found for PIL. 这个提示很费解，只能去找度娘了，原来已经用Pillow代替了PIL，在使用方面没有不同，API都是相同的。真是个挨千刀的，提示信息里怎么不告诉我们这些刚学Python的小白呢，还得白忙活半天。既然这样那就老老实实安装Pillow吧。但是又发现Pillow需要依赖multiprocessing，所以必须先安装multiprocessing。命令如下: 1sudo pip install multiprocessing 接着再执行如下命令： sudo pip install Pillow 引入模块要按照下面的方式写（注意大小写）第一种：from PIL import Image第二种：from PIL.Image(用这种方式时，下面使用时也得写成PIL.Image.open(‘1.png’)，或者可以在引入时修改下模块名，如from PIL.Image as image) 引入之后就可以正常使用了。","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"Java线程常用方法之join()","date":"2017-06-01T08:10:06.000Z","path":"2017/06/01/Java线程常用方法之join()/","text":"join()方法的作用是等待线程销毁。例如在main线程新起一个子线程，子线程需要做一些耗时造作，main线程想要得到子线程执行完成的数据，就必须等到执行完子线程再去执行，这时候就可以用join来解决。 基本使用下面用代码来说明： MyThread类 1234567891011121314class MyThread04 extends Thread&#123; @Override public void run() &#123; try&#123; int value=(int)(Math.random()*1000); System.out.println(&quot;thread04 value=&quot;+value); Thread.sleep(value); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; YieldTest类 12345678910111213public class JoinTest &#123; public static void main(String[] args)&#123; MyThread04 thread04=new MyThread04(); thread04.start();// try &#123;// thread04.join();// &#125;catch (InterruptedException e)&#123;// e.printStackTrace();// &#125; System.out.println(&quot;我想在thread04之后执行&quot;); &#125;&#125; 结果如下： 我想在thread04之后执行thread04 value=8 从结果上看，主线程和子线程是异步的，并没有在子线程执行完之后才执行，而是在子线程执行过程中就执行了主线程。如果想要实现同步的话，需要用到join()方法 将MyThread03类更改一下 1234567891011121314public class JoinTest &#123; public static void main(String[] args)&#123; MyThread04 thread04=new MyThread04(); thread04.start(); try &#123; thread04.join(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;我想在thread04之后执行&quot;); &#125;&#125; 结果如下： thread04 value=323我想在thread04之后执行","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Java线程常用方法之yield()","date":"2017-06-01T07:41:19.000Z","path":"2017/06/01/Java线程常用方法之yield()/","text":"yield()方法的作用是让当前线程放弃当前cup资源，让其他任务获取cup资源。但放弃的时间不确定，有可能放放弃又马上获取cpu资源。 基本使用下面用代码来说明： MyThread类 1234567891011121314class MyThread03 extends Thread&#123; @Override public void run() &#123; long beginTime=System.currentTimeMillis(); int count=0; for (int i=0;i&lt;50000000;i++)&#123;// Thread.yield(); count=count+(i+1); &#125; long endTime=System.currentTimeMillis(); System.out.println(&quot;用时=&quot;+(endTime-beginTime)+&quot;毫秒&quot;); &#125;&#125; YieldTest类 1234567public class YieldTest &#123; public static void main(String[] args)&#123; MyThread03 thread03=new MyThread03(); thread03.start(); &#125;&#125; 结果如下： 用时=23毫秒 将MyThread03类更改一下 1234567891011121314class MyThread03 extends Thread&#123; @Override public void run() &#123; long beginTime=System.currentTimeMillis(); int count=0; for (int i=0;i&lt;50000000;i++)&#123; Thread.yield(); count=count+(i+1); &#125; long endTime=System.currentTimeMillis(); System.out.println(&quot;用时=&quot;+(endTime-beginTime)+&quot;毫秒&quot;); &#125;&#125; 结果如下： 用时=10552毫秒","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Java线程常用方法之sleep()","date":"2017-06-01T07:25:55.000Z","path":"2017/06/01/Java线程常用方法之sleep() /","text":"sleep()方法的作用是在指定的毫秒数中让当前运行的线程休眠，当前的线程指的是this.currentTread() 基本使用下面用代码来说明： MyThread类 1234567891011121314class MyThread02 extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println(&quot;Thread name:&quot;+Thread.currentThread().getName()+&quot;begin=&quot;+System.currentTimeMillis()); Thread.sleep(2000); System.out.println(&quot;Thread name:&quot;+Thread.currentThread().getName()+&quot;end=&quot;+System.currentTimeMillis()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; SleepTest类 123456789public class SleepTest &#123; public static void main(String[] args)&#123; MyThread02 thread02=new MyThread02(); System.out.println(&quot;Begin&quot;); thread02.start(); System.out.println(&quot;end&quot;); &#125;&#125; 结果如下： BeginendThread name:Thread-0begin=1496281723821Thread name:Thread-0end=1496281725822","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Java线程常用方法之isAlive()","date":"2017-05-27T08:49:30.000Z","path":"2017/05/27/Java线程常用方法之isAlive()/","text":"这篇主要来了解一下isAlive()方法，此方法返回当前线程是否处于“活动状态”，何为“活动状态”，线程已经启动尚未终止。 基本使用下面用代码来说明： MyThread类 12345678class MyThread01 extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;Name:&quot;+Thread.currentThread().getName()); System.out.println(&quot;state:&quot;+Thread.currentThread().isAlive()); &#125;&#125; IsAliveTest类 12345678public class IsAliveTest &#123; public static void main(String [] args)&#123; MyThread01 thread01=new MyThread01(); System.out.println(&quot;begin:&quot;+thread01.isAlive()); thread01.start(); System.out.println(&quot;end:&quot;+thread01.isAlive()); &#125;&#125; 结果如下： begin:falseend:trueName:Thread-0state:true 将IsAliveTest类改为如下： 12345678910111213public class IsAliveTest &#123; public static void main(String [] args)&#123; MyThread01 thread01=new MyThread01(); System.out.println(&quot;begin:&quot;+thread01.isAlive()); thread01.start(); try &#123; Thread.sleep(1000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;end:&quot;+thread01.isAlive()); &#125;&#125; 结果如下： begin:falseName:Thread-0state:trueend:false 调用Thread.sleep(1000)让主线程休眠1秒，在这1秒内Thread-0线程已经执行完毕，再调用isAlive()时返回false","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Java线程常用方法之currentThread（）","date":"2017-05-27T08:35:30.000Z","path":"2017/05/27/Java线程常用方法之currentThread()/","text":"Java线程中有很多常用的方法，需要花费一些时间来理解，今天就先来学习一下currentThread（）方法。currentThread（）方法返回调用此代码段的线程信息，其中可以通过 Thread.currentThread().getId()获取当前线程idThread.currentThread().getName()获取当前线程nameThread.currentThread().getPriority()获取当前线程优先级 下面用代码来说明： MyThread类 12345678910class MyThread extends Thread&#123; public MyThread()&#123; System.out.println(&quot;构造方法中打印的线程名字：&quot;+Thread.currentThread().getName()); &#125; @Override public void run() &#123; System.out.println(&quot;run方法中打印的线程名字：&quot;+Thread.currentThread().getName()); &#125;&#125; CurrentThreadTest类 1234567891011public class CurrentThreadTest &#123; public static void main(String[ ]args)&#123; Thread thread=new MyThread(); thread.start();// thread.run(); &#125;&#125; 结果如下： 构造方法中打印的线程名字：mainrun方法中打印的线程名字：Thread-0 说明MyThread类的构造方法被main线程调用的，run方法是自动调用的方法。 将CurrentThreadTest类改为如下： 1234567891011public class CurrentThreadTest &#123; public static void main(String[ ]args)&#123; Thread thread=new MyThread();// thread.start(); thread.run(); &#125;&#125; 结果如下： 构造方法中打印的线程名字：mainrun方法中打印的线程名字：main 说明MyThread类的构造方法被main线程调用的，run方法是被main线程调用的。","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Java线程的五种状态","date":"2017-05-26T09:34:36.000Z","path":"2017/05/26/Java线程的状态 /","text":"什么是线程：一个线程是进程的一个顺序执行流。同类的多个线程共享一块内存空间和一组系统资源，一个进程中可以包含多个线程。 进程与线程的区别一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程状态 新建状态当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。 就绪状态个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。 处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序来调度的。 运行状态（Running）当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法。 阻塞状态（blocked）线程运行过程中，可能由于各种原因进入阻塞状态： ①线程通过调用sleep方法进入睡眠状态； ②线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者； ③线程试图得到一个锁，而该锁正被其他线程持有； ④线程在等待某个触发条件； 所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。 死亡状态有两个原因会导致线程死亡： ①run方法正常退出而自然死亡； ②一个未捕获的异常终止了run方法而使线程猝死； 为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法，如果是可运行或被阻塞，这个方法返回true；如果线程仍旧是new状态且不是可运行的，或者线程死亡了，则返回false。","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Kotlin中val 和var的区别","date":"2017-05-24T07:25:28.000Z","path":"2017/05/24/Kotlin中val 和var的区别/","text":"前几天朋友圈刷爆了关于Kotlin成为Android官方语言的新闻，为了体验一下，开始学习Kotlin的基础语法。其中Kotlin中有两个关键字定义变量var和val,区别如下： var： var是一个可变变量，这是一个可以通过重新分配来更改为另一个值的变量。这种声明变量的方式和Java中声明变量的方式一样。val: val是一个只读变量，这种声明变量的方式相当于java中的final变量。一个val创建的时候必须初始化，因为以后不能被改变。 上段代码体验一下： var name = &quot;lao wang&quot; println(name) name = &quot;xiao wang&quot; println(name) val finalValue = &quot;我万年不变的老李&quot;; println(finalValue); 结果如下： lao wangxiao wang我万年不变的老李","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://suxianglun.github.io/tags/Kotlin/"}]},{"title":"flask_restful安装遇到的问题","date":"2017-05-15T09:40:16.000Z","path":"2017/05/15/安装 Flask-RESTful遇到的问题/","text":"1.使用 pip 安装 Flask-RESTful: pip install flask-restful 使用pip安装第三方库总是提示：You are using pip version 8.0.2, however version 8.1.0 is available 且输入“python -m pip install -U pip”升级pip版本命名还是报同样的错误。 解决办法： 第一步：使用PyCharm，选择file→Setting，找到pip 双击 第二步：按照图片，点击pip，勾选specify version，然后点击 install package 第三步：如果安装出现连接不成功，请使用VPN； 如果出现报错：“UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xd7 in position 9: ordinal not in range(128)”请修改mimetypes.py文件，路径位于python的安装路径下的Lib\\mimetypes.py文件。在import下添加如下几行： 123if sys.getdefaultencoding() != &apos;gbk&apos;: reload(sys) sys.setdefaultencoding(&apos;gbk&apos;) 然后重复第二步操作，安装即可。 注意：其实也可以直接执行第三步，直接修改mimetypes.py文件的信息，然后输入pip升级命令“python -m pip install -U pip” 2.安装过程中遇到的第二个问题：Permission denied: ‘/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/dateutil’ 这里是因为权限问题，需要使用sudo安装，键入如下代码安装： 1sudo pip install flask-restful","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"Java关键字this的使用","date":"2017-05-11T02:44:15.000Z","path":"2017/05/11/Java关键字this的使用/","text":"1.成员变量和局部变量重名时，在方法中使用this时，this代表的是该方法所在类的成员变量。123456789101112131415 public class Hello &#123; String s = &quot;Hello&quot;; public Hello(String s) &#123; System.out.println(&quot;s = &quot; + s); System.out.println(&quot;1 -&gt; this.s = &quot; + this.s); this.s = s;//把参数值赋给成员变量，成员变量的值改变 System.out.println(&quot;2 -&gt; this.s = &quot; + this.s); &#125; public static void main(String[] args) &#123; Hello x = new Hello(&quot;HelloWorld!&quot;); System.out.println(&quot;s=&quot; + x.s);//验证成员变量值的改变 &#125;&#125; 结果为： s = HelloWorld! 1 -&gt; this.s = Hello 2 -&gt; this.s = HelloWorld! s=HelloWorld! 2.把自己当作参数传递时，也可以用this.(this作当前参数进行传递)1234567891011121314151617181920212223242526class A &#123; public A() &#123; new B(this).print();// 调用B的方法 &#125; public void print() &#123; System.out.println(&quot;HelloAA from A!&quot;); &#125;&#125;class B &#123; A a; public B(A a) &#123; this.a = a; &#125; public void print() &#123; a.print();//调用A的方法 System.out.println(&quot;HelloAB from B!&quot;); &#125;&#125;public class HelloA &#123; public static void main(String[] args) &#123; A aaa = new A(); aaa.print(); B bbb = new B(aaa); bbb.print(); &#125;&#125; 结果为：HelloAA from A!HelloAB from B!HelloAA from A!HelloAA from A!HelloAB from B! 3．有时候，我们会用到一些内部类和匿名类，如事件处理。当在匿名类中用this时，这个this则指的是匿名类或内部类本身。这时如果我们要使用外部类的方法和变量的话，则应该加上外部类的类名。123456789101112131415161718192021222324252627public class HelloB &#123; int i = 1; public HelloB() &#123; Thread thread = new Thread() &#123; public void run() &#123; for (int j=0;j&lt;20;j++) &#123; HelloB.this.run();//调用外部类的方法 try &#123; sleep(1000); &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; &#125;; // 注意这里有分号 thread.start(); &#125; public void run() &#123; System.out.println(&quot;i = &quot; + i); i++; &#125; public static void main(String[] args) throws Exception &#123; new HelloB(); &#125;&#125; thread 是一个匿名类对象，在它的定义中，它的 run 函数里用到了外部类的 run 函数。这时由于函数同名，直接调用就不行了。这时有两种办法，一种就是把外部的 run 函数换一个名字，但这种办法对于一个开发到中途的应用来说是不可取的。那么就可以用这个例子中的办法用外部类的类名加上 this 引用来说明要调用的是外部类的方法 run。 4.在构造函数中，调用本类的另一个构造函数。可以使用this调用12345678910111213141516171819public class ThisTest &#123; private int age; private String str; ThisTest(String str) &#123; this.str=str; System.out.println(str); &#125; ThisTest(String str,int age) &#123; this(str); this.age=age; System.out.println(age); &#125; public static void main(String[] args) &#123; ThisTest thistest = new ThisTest(&quot;this测试成功&quot;,25); &#125;&#125; 结果为：this测试成功25 值得注意的是： 1：在构造函数中调用另一个构造函数，调用动作必须置于最起始的位置。 2：不能在构造函数以外的任何函数内调用构造函数。 3：在一个构造函数内只能调用一个构造函数。 4：不能通过this递归调用构造方法，即不能在一个构造方法中通过this直接或间接调用该构造方法本身。 5．this同时传递多个参数。123456789101112131415161718public class TestClass &#123; int x; int y; static void showtest(TestClass tc) &#123;//实例化对象 System.out.println(tc.x + &quot; &quot; + tc.y); &#125; void seeit() &#123; showtest(this); &#125; public static void main(String[] args) &#123; TestClass p = new TestClass(); p.x = 9; p.y = 10; p.seeit(); &#125;&#125; 6.super和this的异同super在一个类中用来引用其父类的成员，它是在子类中访问父类成员的一个桥梁，并不是任何一个对象的引用，而this则表示当前类对象的引用。在代码中Object o = super;是错误的，Object o = this;则是允许的。super关键字的作用在于当子类中覆盖了父类的某个成员变量，或者重写了父类的某个成员方法时还能够访问到父类的成员变量和成员方法。如果子类中没有重写父类的成员变量和成员方法，则子类会继承父类的所有非private的成员变量和成员方法。这时在子类中无论通过this来访问成员和通过super来访问成员，结果都是一样的。 super.getClass()和this.getClass()getClass()是Object类定义的一个final方法，所有Java类的getClass()都继承自Object类。如前文所述，如果子类没有重写父类的某个成员方法，那么通过super来访问还是还是通过this来访问结果都是一样的。因此，super.getClass()和this.getClass()结果是一样的。Object类的getClass()方法返回的是该对象的运行时类，一个对象的运行时类是该对象通过new创建时指定的类。因此，super.getClass()和this.getClass()返回的都是new对象时指定的类。","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"《Python核心编程》学习笔记03（Python对象）","date":"2017-05-05T08:52:32.000Z","path":"2017/05/05/Python核心编程》学习笔记03（Python对象）/","text":"1.标准类型内建函数1.type()type()接受一个对象参数，返回该对象的类型。它的返回值是一个对象的类型。 12&gt;&gt;&gt; type(4) # int type &lt;type &apos;int&apos;&gt; 2.cmp()内建函数cmp(obj1,obj2)用来比较两个对象obj1和obj2的大小，如果obj1比obj2小的话，返回负整数，如果obj1比obj2大的话，返回正整数，如果obj1等于obj2小的话，返回0，比较是在对象之间进行的，不管是标准类型对象还是用户自定 义对象。如果是用户自定义对象， cmp()会调用该类的特殊方法cmp() 1234567&gt;&gt;&gt; a, b = -4, 12 &gt;&gt;&gt; cmp(a,b) -1 &gt;&gt;&gt; cmp(b,a) 1 &gt;&gt;&gt; b = -4 &gt;&gt;&gt; cmp(a,b) 0 &gt;&gt;&gt; &gt;&gt;&gt; a, b = &apos;abc&apos;, &apos;xyz&apos; &gt;&gt;&gt; cmp(a,b) -23 &gt;&gt;&gt; cmp(b,a) 23 &gt;&gt;&gt; b = &apos;abc&apos; &gt;&gt;&gt; cmp(a,b) 0 3.str()和 repr() (及 `` 运算符)str()函数得到的字符串可读性好， 而 repr()函数得到的字符 串通常可以用来重新获得该对象, 通常情况下 obj == eval(repr(obj)) 这个等式是成立的。事实上 repr() 和 “” 做的 是完全一样的事情，它们返回的是一个对象的“官方”字符串表示，但 str()则有所不同。str() 致力 于生成一个对象的可读性好的字符串表示，它的返回结果通常无法用于 eval()求值， 但很适 合用于 print 语句输出。 4.type() 和 isinstance()在Python中可以使用type()与isinstance()这两个函数判断对象类型，而isinstance()函数的使用上比type更加方便。区别就是 对于subclass之类的 type就不行了，所以,强烈建议不要使用type判断对象类型。 12345678910 class A: passclass B(A): passisinstance(A(), A) # returns Truetype(A()) == A # returns Trueisinstance(B(), A) # returns Truetype(B()) == A # returns False 2.标准类型分布 数据类型 存储模型 更新模型 访问模型 数字 标量 不可变 直接访问 字符串 标量 不可变 顺序访问 列表 容器 可变 顺序访问 元祖 容器 不可变 顺序访问 字典 容器 可变 映射访问","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"《Python核心编程》学习笔记02（Python基础）","date":"2017-05-05T07:25:11.000Z","path":"2017/05/05/《Python核心编程》学习笔记02（Python基础）/","text":"1.模块结构和布局合理的布局结构应该如下： 1、起始行：通常只有在类 Unix 环境下才使用起始行，有起始行就能够仅输入脚本名字来执行脚本，无需直接调用解释器。 2、模块文档：简要介绍模块的功能及重要全局变量的含义,模块外可通过 module.doc 访问这些内容。 3、模块导入：导入当前模块的代码需要的所有模块;每个模块仅导入一次(当前模块被加载时);函数内部的模块导入代码不会被执行， 除非该函数正在执行。 4、定义变量：这里定义的变量为全局变量，本模块中的所有函数都可直接使用。从好的编程风格角度说， 除非必须，否则就要尽量使用局部变量代替全局变量，如果坚持这样做，你的代码就不但容易维护，而且还可以 高性能并节省内存。 5、类定义语句：所有的类都需要在这里定义。当模块被导入时 class 语句会被执行, 类也就会被定义。类 的文档变量是 class.doc。 6、方法语句： 此处定义的函数可以通过 module.function()在外部被访问到，当模块被导入时 def 语句 会被执行， 函数也就都会定义好，函数的文档变量是 function.doc。 7、主程序：无论这个模块是被别的模块导入还是作为脚本直接执行，都会执行这部分代码。通常这里 不会有太多功能性代码，而是根据执行的模式调用不同的函数。 2. _ name _ 指示模块应如何被加载由于主程序代码无论模块是被导入还是被直接执行都会运行，我们必须知道模块如何决定 运行方向。一个应用程序可能需要导入另一个应用程序的一个模块，以便重用一些有用的代码 (否则就只能用拷贝粘贴那种非面向对象的愚蠢手段)。这种情况下，你只想访问那些位于其 它应用程序中的代码，而不是想运行那个应用程序。因此一个问题出现了，“Python 是否有 一种方法能在运行时检测该模块是被导入还是被直接执行呢?” 答案就是……(鼓声雷动)…..没错! name 系统变量就是正确答案。 如果模块是被导入， _ name 的值为模块名字如果模块是被直接执行， name 的值为 ‘ main _’ 3.变量和内存管理细节主要包含以下几点： 1、变量无须提前声明2、变量无须制定类型类型3、程序员无须关心内存管理4、变量会被收回5、del 语句能够直接释放资源","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"《Python核心编程》学习笔记01（Python起步）","date":"2017-05-04T05:52:13.000Z","path":"2017/05/04/python核心编程学习笔记01（Python起步）/","text":"1.程序输出print语句及“HelloWorld!”12345&gt;&gt;&gt; myString = &apos;Hello World!&apos; &gt;&gt;&gt; print myString &apos;Hello World!&apos;&gt;&gt;&gt; myString &apos;Hello World!&apos; 1.1._ 和 %在print中的使用下划线(_)在解释器中有特别的含义，表示最后一个表达式的值。所以上面的代码执行之后， 下划线变量会包含字符串: 12&gt;&gt;&gt; _Hello World! Python的print语句，与字符串格式运算符( %)结合使用，可实现字符串替换功能。%s 表示由一个字符串来替换，而%d 表示由一个整数来替换，另外一个很常用的就是%f。它表示由一个浮点数来替换。 12&gt;&gt;&gt; print ‘%s is number %d !’ % (&apos;python&apos;, 1)python is number 1! 2.程序输入和内建函数raw_input()从用户那里得到数据输入的最容易的方法是使用 raw_input()内建函数。它读取标准输入，并将读取到的数据赋值给指定的变量。 12&gt;&gt;&gt; user=raw_input(&apos;henter your name: &apos;)enter your name suxianglun 内建函数 int()将数值字符串转换成整数值，这样才可以对它进行数学运算 1234&gt;&gt;&gt; num = raw_input(&apos;Now enter a number: &apos;)Now enter a number: 1024 &gt;&gt;&gt; print &apos;Doubling your number: %d&apos; % (int(num) * 2) Doubling your number: 2048 3.使用help()函数获取帮助信息help()在交互式解释器中获取帮助信息,在学习 Python 的过程中，如果需要得到一个生疏函数的帮助，只需要对它调用内建函数help()。通过用函数名作为 help()的参数就能得到相应的帮助信息,查看结束退出使用 ：wq进行退出 123&gt;&gt;&gt; help(raw_input)Help on built-in function raw_input in module __builtin__:raw_input(...) raw_input([prompt]) -&gt; string 4. 列表解析表示可以在一行中使用for循环将所得到的的值放在列表中 12&gt;&gt;&gt; squared = [x ** 2 for x in range(4)] &gt;&gt;&gt; for i in squared: ... print i 0 1 4 9 列表解析可以做更复杂的事情 1234567&gt;&gt;&gt;squared = [x ** 2 for x in range(8) if not x%2]&gt;&gt;&gt;for i in squared...print i041636 5.实用的函数 函数 描述 dir([obj]) 显示对象的属性，如果没有提供参数， 则显示全局变量的名字 help([obj]) 以一种整齐美观的形式 显示对象的文档字符串， 如果没有提供任何参 数， 则会进入交互式帮助。 int(obj) 将一个对象转换为整数 len(obj) 返回对象的长度 open(fn, mode) 以 mode(‘r’ = 读， ‘w’= 写)方式打开一个文件名为 fn 的文件 range([[start,]stop[,step]) 返回一个整数列表。起始值为 start, 结束值为 stop - 1; start 默认值为 0， step默认值为1。 raw_input(str) 等待用户输入一个字符串， 可以提供一个可选的参数 str 用作提示信 息。 str(obj) 将一个对象转换为字符串 type(obj) 返回对象的类型(返回值本身是一个 type 对象!)","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"URI和URL含义及其理解","date":"2017-04-28T08:14:03.000Z","path":"2017/04/28/URL和URI含义及理解/","text":"1、URI和URL含义：在理解URL之前先来看一下什么是URI 1.1 什么是URI？简单点说：URI就是通用资源标志符，不理解是吧，我第一次听说也是不理解。进一步说：网络上的一些资源（文档、图片、音频、视频、程序等）都是有一些通用资源标识（Universal Resource Identifier， URI）进行定位的。也就是说如果你想要在网络上找到特定的这些资源，只需知道他们的URI，就可以进行定位，从而找到他们。 通常情况下URI由三部分组成： 1、访问资源的命名机制2、存放资源的主机名3、资源自身的名称，由路径表示 如下面的URI：http://www.jianshu.com/writer#/notebooks/9212154http://可以这样解读： 1、以http机制访问资源2、存在以www.jianshu.com为名的主机上3、资源路径为notebooks/9212154http:// 1.2什么是URLURL是URI的子集，它是Uniform Resource Locator的缩写，统一资源定位符”。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL的格式由三部分组成： ①第一部分是协议(或称为服务方式)。②第二部分是存有该资源的主机IP地址(有时也包括端口号)。③第三部分是主机资源的具体地址，如目录和文件名等。第一部分和第二部分用“://”符号隔开，第二部分和第三部分用“/”符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。 2、URL和URI的区别 URI的定义是：统一资源标识符；URL的定义是：统一资源定位符。URI属于URL更低层次的抽象，一种字符串文本标准。换句话说，URI属于父类，而URL属于URI的子类。URL是URI的一个子集。URI属于URL更低层次的抽象，一种字符串文本标准。换句话说，URI属于父类，而URL属于URI的子类。URL是URI的一个子集。","tags":[{"name":"Web","slug":"Web","permalink":"http://suxianglun.github.io/tags/Web/"}]},{"title":"如何利用Hexo、GitHub pages从零开始创建个人博客","date":"2017-04-19T01:19:42.000Z","path":"2017/04/19/howCreateMyBlog/","text":"从搭建到成功以及本文的诞生，前后花了两天时间，真是一把辛酸泪，感觉还是挺费事的，中途一度想放弃，可还是咬牙坚持下来了，但看到结果后感觉一切的辛苦都是值得的。过程中一定要有耐心，毕竟需要用到的东西挺多的，比如：node.js、git、 github、hexo其中的知识。废话不多说了，详情如下： 一、系统环境配置：要想利用Hexo、GitHub搭建个人博客，首先要安装Node.js、git： 1、Node.js安装：下载Node.js 或者通过如下命令安装： brew install node #最新版的node.js的包中已经集成了npm包管理工具 通过如下命令查看是否安装成功： node -vnpm -v 2、Git安装及配置：下载Git 或者通过如下命令安装： brew install git #Mac电脑使用brew安装sudo apt-get install git #Ubuntu系统使用这条命令安装 配置详见另外一篇博客： git安装与配置 3、Hexo安装： $ npm install hexo -g #-g表示全局安装, npm默认为当前项目安装 如遇错误，请使用一下安装： $ npm install hexo –no-optional 验证是否成功安装： $ hexo -v 目前我用到的环境如下 ，出现类似如下环境说明hexo安装成功 hexo-cli: 1.0.2os: Darwin 16.4.0 darwin x64http_parser: 2.7.0node: 6.10.0v8: 5.1.281.93uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 58.2modules: 48openssl: 1.0.2k 创建博客的根目录并切换到更目录下： $ mkdir myblog$ cd myblog 初始化myblog文件夹使其成为Hexo博客： $ hexo init 自动根据当前目录下文件,生成静态网页： $ hexo generate 运行本地服务： $ hexo server 有必要提下Hexo常用的几个命令： $ hexo new “postName” #新建文章$ hexo new page “pageName” #新建页面$ hexo generate (或者hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹$ hexo server (或者hexo s) 启动本地web服务，用于博客的预览$ hexo deploy (或者hexo d) 部署播客到远端（比如github, coding等平台） 常用简写： $ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy 常用组合： $ hexo d -g #生成部署$ hexo s -g #生成预览 通过hexo g生成静态文件和hexo s启动本地web服务后，现在我们打开http://localhost:4000/ 就可以看到一篇内置的blog了。看到后是不是感觉很有成就感？反正我是这么认为的。 二、Hexo主题设置默认的主题是landscape，这里以主题yilia为例进行说明。Hexo中文官网：下载主题、配置详解 安装主题 $ hexo clean$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改主题 修改myblog目录下的_config.yml配置文件中的theme属性，将其设置为yilia。并按照主题说明进行相关的配置，这点很重要，否则修改后的主题样式会有变化例如：git clone https://github.com/GeekaholicLin/hexo-theme-ylion.git这个主题就需要在_config.yml配置文件添加如下内容： search插件基于 https://github.com/PaicHyperionDev/hexo-&gt;generator-search使用说明请参考该reposearch: path: search.xml field: all 更新主题 $ hexo g # 生成$ hexo s # 启动本地web服务器 三、GitHub Pages配置1、注册、登录GitHubgithub官网：https://github.com/ 你值得拥有 2、创建项目仓库注册并登陆Github官网成功后，点击页面右上角的+，选择New repository。 你值得拥有 3、填写项目名在Repository name中填写：Github账号名.github.io 必须这样填，否则会出错 例如我的账号为:allen,那么就必须填allen.github.io 你值得拥有 4、设置GitHub pages打开settings，有一个Github Pages 的设置，点击 source 中的本来的 None ，使其变成 master 分支，也就是作为部署github pages 的分支，然后点击 save。 你值得拥有 5、查看网址页面刷新之后，再看 github pages 设置框处，多了一行网址，就是你的 github pages 的网址了，点击进去就进入属于你自己的博客网址了。 你值得拥有 四、部署到GitHub pages1、修改_config.yml千万要注意冒号：后边要留有空格 基本设置 title: allensubtitle: welcome to allen blogdescription:author: John Doelanguage: zh-CN #语言timezone: #时区 URLIf your site is put in a subdirectory, set url as ‘http://yoursite.com/child‘ and root as ‘/child/‘ url: http://suxianglun.github.io #用于绑定域名, 其他的不需要配置，即为GitHub pages生成的那个网址root: /permalink: :year/:month/:day/:title/permalink_defaults: ExtensionsPlugins: https://hexo.io/plugins/Themes: https://hexo.io/themes/theme: hexo-theme-landfarz #主题设置 DeploymentDocs: https://hexo.io/docs/deployment.htmldeploy: #部署, 发布在 GitHub 上面 type: git repo: git@github.com:suxianglun/suxianglun.github.io.git #GitHub 项目仓库 branch: master 2、部署到GitHub 上 $ hexo clean #清除$ hexo g #生成$ hexo d #部署 # 可与hexo g合并为 hexo d -g $ hexo d 之后如果出现ERROR Deployer not found: Git,请键入如下命令 $ npm install hexo-deployer-git –save 部署之后去查看GitHub pages那个网址http://suxianglun.github.io，有可能会出现:Your site is having problems building: unable to build page. Please try again later. 或者Your page is having problems building: page build failed同时也会收到github发来的page build failure的邮件，但是邮件中显示的错误信息和settings页面上的一样, 就这句话, 什么都没有, 没有任何错误提示.我就卡在这一天，后来用了好长时间来解决了。我分析的主要原因如下：1、Hexo未进行构建html,即未执行hexo g,这个过程需要一段时间，构建好html后myblog根目录下完整目录应该如下： README.md db.json package.json scaffolds themes_config.yml node_modules public source 2、Hexo 配置不正确，请严格按照要求进行配置 注意事项：markdown标题标准写法写法需要在”#”和后面字符之间加一个空格如果不加空格 有些引擎就解析不了 另外说一下我的个人博客地址 https://suxianglun.github.io/ 欢迎来骚扰。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://suxianglun.github.io/tags/Hexo/"}]},{"title":"Android studio下JNI开发","date":"2017-04-05T03:11:48.000Z","path":"2017/04/05/Android studio下JNI和NDK开发/","text":"1.下载Ndk并配置点菜单栏的File-&gt;ProjectStructure…-&gt;在打开的窗口中左侧选中SDKLocation-&gt;在右侧Android NDK Location中填入NDK目录所在路径，如下图所示： 2. 新建项目JniDemo1. 新建类JniUtil,声明所需要的native方法：getJniAdd(int a,int b),代码如下:public class JniUtil { static { System.loadLibrary(&quot;JniUtil&quot;); } public static native int getJniAdd(int a, int b); } 2. 生成Java文件中native方法相对应的jin层c代码接口在AS界面的Terminal窗口中执行命令：cd app/src/main/java定位至java文件夹，然后再执行命令：javah -jni com.richsoft.jnidemo.JniUtil注意”com.richsoft.jnidemo”是JniUtil所在的包名。此时在app/src/main/java路径下生成了一个.h文件，如图： 3.新建jni文件夹app-&gt;new-&gt;Floder-&gt;JNI Folder,如下图： 点击之后弹出选择框： 点击finish之后，main文件夹下生成jni文件夹，如下图： 4.实现项目中声明的Native方法在jni目录下创建JniUtil.c文件,然后将com_richsoft_jnidemo_JniUtil.h中的方法拷贝至JniUtil.c中，并实现这个方法，如下代码： #include&lt;jni.h&gt; JNIEXPORT jint JNICALL Java_com_richsoft_jnidemo_JniUtil_getJniAdd (JNIEnv *env, jclass cls, jint a, jint b) { return a + b; } 3.编译.so文件1.gradle内添加代码：在gradle.properties文件末尾添加上“android.useDeprecatedNdk=true”然后在app文件下build.grade－&gt;defaultConfig括号内添加如下代码： ndk { moduleName &quot;JniUtil&quot; //生成的so名字 abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot; ,&quot;x86&quot;//输出指定三种abi体系结构下的so库，目前可有可无。 } 2.build 项目点击Build下的Make Project,成功之后打开app-&gt;intermediates-&gt;ndk-&gt;debug发现了四个文件夹,如下图： 到此，生成.so文件的过程结束。在src\\main下新建jniLibs文件夹，将上面的四个文件夹拷贝至jniLibs文件夹下，如图： 将jni文件夹和.h文件删除，如下图： 最后咱们试试生成的.so文件能不能用，贴下MainActivity代码： public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = (TextView) findViewById(R.id.tv); tv.setText(&quot;java调用C语言实现的加法运算:2+1000=&quot; + JniUtil.getJniAdd(2, 10000)); } } 运行下程序，结果如下：","tags":[{"name":"Android","slug":"Android","permalink":"http://suxianglun.github.io/tags/Android/"}]}]