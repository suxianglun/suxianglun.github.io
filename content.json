[{"title":"Python中可变对象和不可变对象","date":"2018-04-23T16:00:00.000Z","path":"2018/04/24/Python中可变对象和不可变对象/","text":"Python中可变对象和不可变对象python中对象可分为：可变对象和不可变对象先从数据类型角度理解可变对象和不可变对象。 抽象数据类型的操作一般分为三类： 123456781、构造操作: 这类操作主要是基于一些已知信息，产生这个类的实例对象。类似银行进行开通账户 2、解析操作：这类操作是获取对象的一些有用信息，其结果反应了对象的一些特征，但返回的不是对象本身。类似银行查询账户余额 3、变化操作 ：这类操作是修改对象内部的信息和状态。比如一个银行账户进行转账操作如果一个类型，具只具有1和2两种操作，也就说只具有构造和解析操作，那么这个类型就是不可变类型，这个类型的对象就是不可变对象如果一个类型，具有1、2、3三种操作，这个类型就是可变类型，这个类型的对象就是可变对象。 可变对象：对象所指向的内存中的值不能被改变，当改变这个变量的时候，原来指向的内存中的值不变，变量不再指向原来的值，而是开辟一块新的内存，变量指向新的内存。举个例子： 1234567891011&gt;&gt;&gt; a=5&gt;&gt;&gt; print id(a)140433054259208&gt;&gt;&gt; a= 4&gt;&gt;&gt; print id(a)140433054259232&gt;&gt;&gt; print id(a),id(4)140433054259232 140433054259232&gt;&gt;&gt; print id(a),id(5)140433054259232 140433054259208&gt;&gt;&gt; 打印的结果表明：不可变对象int的变量a改变后，未改变之前指向内存中5，改变后开辟一块新内存指向4由于是不可变对象，变量对应内存的值不允许被改变。当变量要改变时，实际上是把原来的值复制一份后再改变，开辟一个新的地址，astr再指向这个新的地址（所以前后astr的id不一样），原来astr对应的值因为不再有对象指向它,就会被垃圾回收。 再来看一下字符串str 12345678&gt;&gt;&gt; a=&apos;hello&apos;&gt;&gt;&gt; print id(a)4385118896&gt;&gt;&gt; a =a +&apos; world&apos;&gt;&gt;&gt; print ahello world&gt;&gt;&gt; print id(a)4385119040 结果是一样的，也是开辟新内存，指向新内存中的值 不可变对象：对象指向的内存中的值会改变，当更改这个变量的时候，还是指向原来内存中的值，并且在原来的内存值进行原地修改，并没有开辟新的内存。 12345678&gt;&gt;&gt; list=[1,2,3,4]&gt;&gt;&gt; print id(list)4384947808&gt;&gt;&gt; list[2]=5&gt;&gt;&gt; print list[1, 2, 5, 4]&gt;&gt;&gt; print id(list)4384947808 结果表明: 列表list在改变前后id并未发生改变，可变对象由于所指对象可以被修改，所以无需复制一份之后再改变，直接原地改变，所以不会开辟新的内存，改变前后id不变。 在Python中，数值类型int 、float、 字符串str 、元祖tuple、boole 都是不可变对象列表list、集合set、字典dict都是可变对象 -","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"Java中Synchronized的用法","date":"2018-03-06T16:00:00.000Z","path":"2018/03/07/Java中Synchronized的用法/","text":"原文 ：http://blog.csdn.net/luoweifu/article/details/46613015 Java中Synchronized的用法synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 - 修饰一个代码块一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。我们看下面一个例子： Demo1: 123456789101112131415161718192021222324252627/** * 同步线程 */class SyncThread implements Runnable &#123; private static int count; public SyncThread() &#123; count = 0; &#125; public void run() &#123; synchronized(this) &#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++)); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public int getCount() &#123; return count; &#125;&#125; SyncThread的调用: 12345SyncThread syncThread = new SyncThread();Thread thread1 = new Thread(syncThread, &quot;SyncThread1&quot;);Thread thread2 = new Thread(syncThread, &quot;SyncThread2&quot;);thread1.start();thread2.start(); 结果如下： SyncThread1:0SyncThread1:1SyncThread1:2SyncThread1:3SyncThread1:4SyncThread2:5SyncThread2:6SyncThread2:7SyncThread2:8SyncThread2:9 当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。我们再把SyncThread的调用稍微改一下： 1234Thread thread1 = new Thread(new SyncThread(), &quot;SyncThread1&quot;);Thread thread2 = new Thread(new SyncThread(), &quot;SyncThread2&quot;);thread1.start();thread2.start(); 结果如下： SyncThread1:0SyncThread2:1SyncThread1:2SyncThread2:3SyncThread1:4SyncThread2:5SyncThread2:6SyncThread1:7SyncThread1:8SyncThread2:9 不是说一个线程执行synchronized代码块时其它的线程受阻塞吗？为什么上面的例子中thread1和thread2同时在执行。这是因为synchronized只锁定对象，每个对象只有一个锁（lock）与之相关联，而上面的代码等同于下面这段代码： 123456SyncThread syncThread1 = new SyncThread();SyncThread syncThread2 = new SyncThread();Thread thread1 = new Thread(syncThread1, &quot;SyncThread1&quot;);Thread thread2 = new Thread(syncThread2, &quot;SyncThread2&quot;);thread1.start();thread2.start(); 这时创建了两个SyncThread的对象syncThread1和syncThread2，线程thread1执行的是syncThread1对象中的synchronized代码(run)，而线程thread2执行的是syncThread2对象中的synchronized代码(run)；我们知道synchronized锁定的是对象，这时会有两把锁分别锁定syncThread1对象和syncThread2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。 - 2.当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。 Demo2：多个线程访问synchronized和非synchronized代码块 1234567891011121314151617181920212223242526272829303132333435363738394041class Counter implements Runnable&#123; private int count; public Counter() &#123; count = 0; &#125; public void countAdd() &#123; synchronized(this) &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++)); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //非synchronized代码块，未对count进行读写操作，所以可以不用synchronized public void printCount() &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; count:&quot; + count); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void run() &#123; String threadName = Thread.currentThread().getName(); if (threadName.equals(&quot;A&quot;)) &#123; countAdd(); &#125; else if (threadName.equals(&quot;B&quot;)) &#123; printCount(); &#125; &#125;&#125; 调用代码: 12345Counter counter = new Counter();Thread thread1 = new Thread(counter, &quot;A&quot;);Thread thread2 = new Thread(counter, &quot;B&quot;);thread1.start();thread2.start(); 结果如下： A:0B count:1A:1B count:2A:2B count:3A:3B count:4A:4B count:5 上面代码中countAdd是一个synchronized的，printCount是非synchronized的。从上面的结果中可以看出一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。 指定要给某个对象加锁 【Demo3】:指定要给某个对象加锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 银行账户类 */class Account &#123; String name; float amount; public Account(String name, float amount) &#123; this.name = name; this.amount = amount; &#125; //存钱 public void deposit(float amt) &#123; amount += amt; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //取钱 public void withdraw(float amt) &#123; amount -= amt; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public float getBalance() &#123; return amount; &#125;&#125;/** * 账户操作类 */class AccountOperator implements Runnable&#123; private Account account; public AccountOperator(Account account) &#123; this.account = account; &#125; public void run() &#123; synchronized (account) &#123; account.deposit(500); account.withdraw(500); System.out.println(Thread.currentThread().getName() + &quot;:&quot; + account.getBalance()); &#125; &#125;&#125; 调用代码: 123456789Account account = new Account(&quot;zhang san&quot;, 10000.0f);AccountOperator accountOperator = new AccountOperator(account);final int THREAD_NUM = 5;Thread threads[] = new Thread[THREAD_NUM];for (int i = 0; i &lt; THREAD_NUM; i ++) &#123; threads[i] = new Thread(accountOperator, &quot;Thread&quot; + i); threads[i].start();&#125; 结果如下： Thread3:10000.0Thread2:10000.0Thread1:10000.0Thread4:10000.0Thread0:10000.0 在AccountOperator 类中的run方法里，我们用synchronized 给account对象加了锁。这时，当一个线程访问account对象时，其他试图访问account对象的线程将会阻塞，直到该线程访问account对象结束。也就是说谁拿到那个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以用类似下面这样的方式写程序。 12345678public void method3(SomeObject obj)&#123; //obj 锁定的对象 synchronized(obj) &#123; // todo &#125;&#125; 当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁： 1234567891011121314class Test implements Runnable&#123; private byte[] lock = new byte[0]; // 特殊的instance变量 public void method() &#123; synchronized(lock) &#123; // todo 同步代码块 &#125; &#125; public void run() &#123; &#125;&#125; 说明：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。 修饰一个方法Synchronized修饰一个方法很简单，就是在方法的前面加synchronized，public synchronized void method(){//todo}; synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。如将【Demo1】中的run方法改成如下的方式，实现的效果一样。 【Demo4】：synchronized修饰一个方法 12345678910public synchronized void run() &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++)); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Synchronized作用于整个方法的写法。 写法一： 1234public synchronized void method()&#123; // todo&#125; 写法二： 123456public void method()&#123; synchronized(this) &#123; // todo &#125;&#125; 写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。 在用synchronized修饰方法时要注意以下几点： synchronized关键字不能继承。虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下：在子类方法中加上synchronized关键字 123456class Parent &#123; public synchronized void method() &#123; &#125;&#125;class Child extends Parent &#123; public synchronized void method() &#123; &#125;&#125; 在子类方法中调用父类的同步方法 123456class Parent &#123; public synchronized void method() &#123; &#125;&#125;class Child extends Parent &#123; public void method() &#123; super.method(); &#125;&#125; 1.在定义接口方法时不能使用synchronized关键字。2.构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。 - 修饰一个静态的方法Synchronized也可修饰一个静态方法，用法如下： 123public synchronized static void method() &#123; // todo&#125; 我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。我们对Demo1进行一些修改如下： 【Demo5】：synchronized修饰静态方法 12345678910111213141516171819202122232425/** * 同步线程 */class SyncThread implements Runnable &#123; private static int count; public SyncThread() &#123; count = 0; &#125; public synchronized static void method() &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++)); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public synchronized void run() &#123; method(); &#125;&#125; 调用代码: 123456SyncThread syncThread1 = new SyncThread();SyncThread syncThread2 = new SyncThread();Thread thread1 = new Thread(syncThread1, &quot;SyncThread1&quot;);Thread thread2 = new Thread(syncThread2, &quot;SyncThread2&quot;);thread1.start();thread2.start(); 结果如下： &gt;SyncThread1:0SyncThread1:1SyncThread1:2SyncThread1:3SyncThread1:4SyncThread2:5SyncThread2:6SyncThread2:7SyncThread2:8SyncThread2:9 syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与Demo1是不同的。 - 修饰一个类Synchronized还可作用于一个类，用法如下： 1234567class ClassName &#123; public void method() &#123; synchronized(ClassName.class) &#123; // todo &#125; &#125;&#125; 我们把Demo5再作一些修改。 【Demo6】:修饰一个类 123456789101112131415161718192021222324252627/** * 同步线程 */class SyncThread implements Runnable &#123; private static int count; public SyncThread() &#123; count = 0; &#125; public static void method() &#123; synchronized(SyncThread.class) &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++)); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public synchronized void run() &#123; method(); &#125;&#125; 其效果和【Demo5】是一样的，synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。 -总结：A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 -","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"HTTP和HTTPS之间的区别","date":"2018-01-28T16:00:00.000Z","path":"2018/01/29/HTTP和HTTPS之间的区别/","text":"HTTP和HTTPS之间的区别HTTP和HTTPS的定义HTTPHTTP:超文本传输协议，HTTP 使用请求/响应的过程，因此信息可在服务器间快速、轻松而且精确的进行传输，但它使用的是明文进行传输，不安全 HTTPSHTTPS:https使用的是具有安全性的SSL加密传输协议。HTTPS 在 HTTP 应用层的基础上使用安全套接字层作为子层。HTTPS = HTTP + SSL SSLSSL:安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议。SSL协议的三个特性 Ø 保密：在握手协议中定义了会话密钥后，所有的消息都被加密。 Ø 鉴别：可选的客户端认证，和强制的服务器端认证。 Ø 完整性：传送的消息包括消息完整性检查（使用MAC）。 HTTP 和 HTTPS 的相同点都是采用同一个基础的协议，作为 HTTP 或 HTTPS 客户端——浏览器，设立一个连接到 Web 服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。系统使用统一资源定位器 URI 模式，因此资源可以被唯一指定。 HTTP 和 HTTPS 的不同之处1、HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头2、HTTP 是不安全的，而 HTTPS 是安全的3、HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 4434、在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层5、HTTP 无需加密，而 HTTPS 对传输的数据进行加密6、HTTP 无需证书，而 HTTPS 需要认证证书 HTTPS 如何工作?使用 HTTPS 连接时，服务器要求有公钥和签名的证书。 当使用 https 连接，服务器响应初始连接，并提供它所支持的加密方法。作为回应，客户端选择一个连接方法，并且客户端和服务器端交换证书验证彼此身份。完成之后，在确保使用相同密钥的情况下传输加密信息，然后关闭连接。为了提供 https 连接支持，服务器必须有一个公钥证书，该证书包含经过证书机构认证的密钥信息，大部分证书都是通过第三方机构授权的，以保证证书是安全的。 换句话说，HTTPS 跟 HTTP 一样，只不过增加了 SSL。 HTTP 包含如下动作： 浏览器打开一个 TCP 连接浏览器发送 HTTP 请求到服务器端服务器发送 HTTP 回应信息到浏览器TCP 连接关闭 SSL 包含如下动作： 验证服务器端允许客户端和服务器端选择加密算法和密码，确保双方都支持验证客户端(可选)使用公钥加密技术来生成共享加密数据创建一个加密的 SSL 连接基于该 SSL 连接传递 HTTP 请求 什么时候该使用 HTTPS?银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应该使用 HTTPS","tags":[{"name":"Web","slug":"Web","permalink":"http://suxianglun.github.io/tags/Web/"}]},{"title":"Android使用gradle自动获取svn版本号","date":"2018-01-28T16:00:00.000Z","path":"2018/01/29/Android使用gradle自动获取svn版本号/","text":"Android使用gradle自动获取svn版本号由于我们公司项目在内网开发版本控制使用的是svn,为了方便测试同学提bug,以及开发同学及时定位bug，需要自动获取svn版本号。亲测有效， 1、Project层下的 build.gradle 文件 引入svn插件1classpath group: &apos;org.tmatesoft.svnkit&apos;, name: &apos;svnkit&apos;, version: &apos;1.8.11&apos; 在我的项目中如下： 1234567891011buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.0.0&apos; classpath group: &apos;org.tmatesoft.svnkit&apos;, name: &apos;svnkit&apos;, version: &apos;1.8.11&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 2、Module层下的 build.gradle 文件加入以下两个步骤中内容：2.1、在文件第一行导包1import org.tmatesoft.svn.core.wc.* 2.2、定义函数12345678def getSvnRevision() &#123; ISVNOptions options = SVNWCUtil.createDefaultOptions(true); SVNClientManager clientManager = SVNClientManager.newInstance(options); SVNStatusClient statusClient = clientManager.getStatusClient(); SVNStatus status = statusClient.doStatus(projectDir, false); SVNRevision revision = status.getCommittedRevision(); return revision.getNumber();&#125; 在我的项目中整体如下： 1234567891011121314151617181920212223242526272829import org.tmatesoft.svn.core.wc.*apply plugin: &apos;com.android.application&apos;//通过svnKit自动获取svn版本号def getSvnRevision() &#123; ISVNOptions options = SVNWCUtil.createDefaultOptions(true) SVNClientManager clientManager = SVNClientManager.newInstance(options) SVNStatusClient statusClient = clientManager.getStatusClient() SVNStatus status = statusClient.doStatus(projectDir, false) SVNRevision revision = status.getCommittedRevision() return revision.getNumber()&#125;android &#123; compileSdkVersion 23 buildToolsVersion &apos;26.0.2&apos; aaptOptions.cruncherEnabled = false aaptOptions.useNewCruncher = false lintOptions &#123; abortOnError false &#125; defaultConfig &#123; applicationId &quot;com.citicbank.comb&quot; minSdkVersion 15 targetSdkVersion 16 versionCode 2 versionName &quot;$&#123;getSvnRevision()&#125;&quot; //调用方法获取svn版本号 &#125; 3、java代码中获取svn版本号主要是通过PackageManager获取PackageInfo,从而获取svn版本号，在需要svn版本号的地方，只需调用此方法即可 1234567891011public static String getVersionName(Context context) &#123; PackageManager packageManager = context.getPackageManager(); PackageInfo packInfo = null; try &#123; packInfo = packageManager.getPackageInfo(context.getPackageName(), 0); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; String version = packInfo.versionName; return version; &#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://suxianglun.github.io/tags/Android/"}]},{"title":"Kotlin基础语法","date":"2018-01-16T16:00:00.000Z","path":"2018/01/17/Kotlin基础语法/","text":"Kotlin基础语法1、包声明1234567package com.citic.combimport android.os.Bundleimport android.support.v7.app.AppCompatActivityimport android.view.Viewimport android.widget.Toastimport kotlinx.android.synthetic.main.activity_main.* 2、变量定义可变变量定义：var 关键字 var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量) val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 栗子在下面👇 1234val str : String=&quot;你好&quot;var int : Int=2val b = 3 // 系统自动推断变量类型为Intvar c :Int = 0 3、NULL检查机制：当某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空。这也是kotlin的特性 。Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理 1234567891011//类型后面加?表示可为空var age: String? = &quot;23&quot; //抛出空指针异常val ages = age!!.toInt()//不做处理返回 nullval ages1 = age?.toInt()//age为空返回-1val ages2 = age?.toInt() ?: -1 当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。当 str 中的字符串内容不是一个整数时, 返回 null: 123fun parseInt(str: String): Int? &#123; // ...&#125; 以下实例演示如何使用一个返回值可为 null 的函数: 12345678910111213fun main(args: Array&lt;String&gt;) &#123; if (args.size &lt; 2) &#123; print(&quot;Two integers expected&quot;) return &#125; val x = parseInt(args[0]) val y = parseInt(args[1]) // 直接使用 `x * y` 会导致错误, 因为它们可能为 null. if (x != null &amp;&amp; y != null) &#123; // 在进行过 null 值检查之后, x 和 y 的类型会被自动转换为非 null 变量 print(x * y) &#125;&#125; 4、类型检测及自动类型转换我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。 1234567891011121314fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 做过类型判断以后，obj会被系统自动转换为String类型 return obj.length &#125; //在这里还有一种方法，与Java中instanceof不同，使用!is // if (obj !is String)&#123; // // XXX // &#125; // 这里的obj仍然是Any类型的引用 return null&#125; 或者 123456fun getStringLength(obj: Any): Int? &#123; if (obj !is String) return null // 在这个分支中, `obj` 的类型会被自动转换为 `String` return obj.length&#125; 甚至还可以 123456fun getStringLength(obj: Any): Int? &#123; // 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String` if (obj is String &amp;&amp; obj.length &gt; 0) return obj.length return null&#125; 5、函数定义函数定义使用关键字 fun，参数格式为：参数 : 类型 123fun sum(a: Int, b: Int): Int &#123; // Int 参数，返回值 Int return a + b&#125; 表达式作为函数体，返回类型自动推断：123fun sum(a: Int, b: Int) = a + bpublic fun sum(a: Int, b: Int): Int = a + b // public 方法则必须明确写出返回类型 无返回值的函数(类似Java中的void)：123456789fun printSum(a: Int, b: Int): Unit &#123; print(a + b)&#125;// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：public fun printSum(a: Int, b: Int) &#123; print(a + b)&#125; 可变长参数函数函数的变长参数可以用 vararg 关键字进行标识： 12345678910fun vars(vararg v:Int)&#123; for(vt in v)&#123; print(vt) &#125;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; vars(1,2,3,4,5) // 输出12345&#125; lambda(匿名函数)lambda表达式使用实例 12345// 测试fun main(args: Array&lt;String&gt;) &#123; val sumLambda: (Int, Int) -&gt; Int = &#123;x,y -&gt; x+y&#125; println(sumLambda(1,2)) // 输出 3&#125; 6、注释Kotlin 支持单行和多行注释，实例如下： 1234// 这是一个单行注释/* 这是一个多行的 块注释。 */ 7、字符串模板$ 表示一个变量名或者变量值 $varName 表示变量值 ${varName.fun()} 表示变量的方法返回值: 123456789var a = 1// 模板中的简单名称：val s1 = &quot;a is $a&quot; print（s1）a = 2// 模板中的任意表达式：val s2 = &quot;$&#123;s1.replace(&quot;is&quot;, &quot;was&quot;)&#125;, but now is $a&quot;print（s2） 输出结果： a is 1a was 1 ,but now is 2 8、区间区间表达式由具有操作符形式 .. 的 rangeTo 函数辅以 in 和 !in 形成。 区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例: 123456789101112131415161718for (i in 1..4) print(i) // 输出“1234”for (i in 4..1) print(i) // 什么都不输出if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i)&#125;// 使用 step 指定步长for (i in 1..4 step 2) print(i) // 输出“13”for (i in 4 downTo 1 step 2) print(i) // 输出“42”// 使用 until 函数排除结束元素for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 println(i)&#125; 实例测试 1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123; print(&quot;循环输出：&quot;) for (i in 1..4) print(i) // 输出“1234” println(&quot;\\n----------------&quot;) print(&quot;设置步长：&quot;) for (i in 1..4 step 2) print(i) // 输出“13” println(&quot;\\n----------------&quot;) print(&quot;使用 downTo：&quot;) for (i in 4 downTo 1 step 2) print(i) // 输出“42” println(&quot;\\n----------------&quot;) print(&quot;使用 until：&quot;) // 使用 until 函数排除结束元素 for (i in 1 until 4) &#123; // i in [1, 4) 排除了 4 print(i) &#125; println(&quot;\\n----------------&quot;)&#125; 输出结果： 12345678循环输出：1234----------------设置步长：13----------------使用 downTo：42----------------使用 until：123----------------","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://suxianglun.github.io/tags/Kotlin/"}]},{"title":"Android四大组件之Service","date":"2017-11-07T14:53:12.000Z","path":"2017/11/07/Android四大组件之Service/","text":"Android四大组件之Service（1）1、Service概念、作用及特点先看一下源码里对Service的解释 12345678910111213141516171819* A Service is an application component representing either an application&apos;s desire * to perform a longer-running operation while not interacting with the user * or to supply functionality for other applications to use. Each service * class must have a corresponding * &#123;@link android.R.styleable#AndroidManifestService &amp;lt;service&amp;gt;&#125; * declaration in its package&apos;s &lt;code&gt;AndroidManifest.xml&lt;/code&gt;. Services * can be started with * &#123;@link android.content.Context#startService Context.startService()&#125; and * &#123;@link android.content.Context#bindService Context.bindService()&#125;. * * &lt;p&gt;Note that services, like other application objects, run in the main * thread of their hosting process. This means that, if your service is going * to do any CPU intensive (such as MP3 playback) or blocking (such as * networking) operations, it should spawn its own thread in which to do that * work. More information on this can be found in * &lt;a href=&quot;&#123;@docRoot&#125;guide/topics/fundamentals/processes-and-threads.html&quot;&gt;Processes and * Threads&lt;/a&gt;. The &#123;@link IntentService&#125; class is available * as a standard implementation of Service that has its own thread where it * schedules its work to be done.&lt;/p&gt; 从上边看出以下信息： 123456概念：服务为Android四大组件之一 作用：提供在后台需要长期运行的服务（如复杂计算、下载等等）运行地方：在主线程中注意事项：使用前必须在AndroidManifest.xml注册，如果要进行长期的运行需要自己的线程，即新建一个线程，也可以使用标准的IntentService。启动方式：startService()和bindService()特点：长生命周期的、没有用户界面、在后台运行 2、Service分类、各自特点及应用场景 Service分类 3、Service与Thread的区别：应该说Service和Thread没有任何联系，唯一相同点就是执行异步操作，由于Service有后台的概念，很容易将其和Thread混为一谈。一般来说，会将Service和Thread联合着用，即在Service中再创建一个子线程（工作线程）去处理耗时操作逻辑. 1234567891011@Override public int onStartCommand(Intent intent, int flags, int startId) &#123; //新建工作线程 new Thread(new Runnable() &#123; @Override public void run() &#123; // 开始执行后台任务 &#125; &#125;).start(); return super.onStartCommand(intent, flags, startId); &#125; 后台的定义：后台任务运行完全不依赖UI，即使Activity被销毁，或者程序被关闭，只要进程还在，后台任务就可以继续运行 4、Service生命周期手动调用的方法： 手动调用的方法 作用 自动调用的内部方法 startService() 启动服务 onCreate()、onStartCommand() stopService() 停止服务 onDestroy() bindService() 绑定服务 onCreate()、onBind() unbindService() 解绑服务 onUnBind()、 onDestroy() 内部自动调用的方法： 内部自动调用的方法 作用 说明 onCreate() 创建服务 首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。 onStartCommand() 开始服务 当另外一个组件（Activity）使用startService()启动服务的时候调用此方法。onStartCommmand()调用次数==启动次数，一旦执行此方法，服务即会启动并可在后台无限期运行。 onBind() 绑定服务 当另一个组件通过bindService()绑定服务时，系统会调用此方法， onUnBind() 解绑服务 调用 onDestroy() 销毁服务 当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。 Service 两种形式 启动状态当应用组件（例如Activity）通过startService（）启动服务后，Service就处于启动状态，就会一直运行下去，除非手动调用stopServiec() 绑定状态与启动服务不同的是绑定服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说宿主(如Activity)解除绑定后，绑定服务就会被销毁 此文章参考以下出处：http://blog.csdn.net/javazejian/article/details/52709857http://www.jianshu.com/p/d963c55c3ab9/","tags":[{"name":"Android","slug":"Android","permalink":"http://suxianglun.github.io/tags/Android/"}]},{"title":"Android四大组件之Activity","date":"2017-11-03T03:23:02.000Z","path":"2017/11/03/Android四大组件之Activity  /","text":"Android四大组件之Activity1、Activity生命周期一般情况下Activity会经历如下生命周期：为了方便先上一下官方的Activity生命周期图解 （1）onCreate()： 表示activity正在被创建，是activity的第一个生命周期，在这期间进行页面的初始化，setContenView()加载页面布局资源、初始化一些变量等工作。 （2）onStart()： 表示activity正在启动，这个时候已经可见，但是还未出现在前台，不能和用户进行交互。这个时候activity已经出来了但我们看不到。 （3）onResume()： 表示activity已经可见了，位于前台了，可以和用户进行交互。和onStart的相同点和区别：onStart和onResume时期Activity都已可见，但onStart不在前台，不能与用户进行交互，而onResume已在前台，可以和用户进行交互。 （4）onPause()： 表示activity正在暂停，正常情况下紧接着就执行onStop,这期间可以进行一些动画停止、数据存储工作。但不能耗时，否则会影响新activity的启动。因为启动新activity时，执行onPause()后就会执行新Activity的onCreate （5）onStop()： 表示activity即将停止，这期间可以做一些重量级的回收工作。但不能太耗时 （6）onDestroy()： 表示activity即将被销毁，这是activity最后一个生命周期，这期间可以做一些回收工作和资源回收。 （7）onRestart()： 表示activity重新启动，即从不可见状态变为可见状态时就会被调用，一般情况下都是用户操作才会调用，例如用户操作Home键或者启动一个新页面，旧页面会执行onPause和onStop，然后再回到旧页面，这时就会调用onRestart，然后再调用onStart和onResume 2、Activity启动模式 2.1、standard Activity默认的启动模式，每次启动Activity都会创建一个新的实例，放入任务栈中。这是一个典型的多实例，每一个任务栈可以有多个Activity，每个Activity可以属于多个任务栈。哪个Activity启动了当前Activity，当前Activity就放入改Activity所在的任务栈。比如Activity A启动了Activity B，那么Activity B就位于Activity A所在的任务栈中。此模式下onCreate()、onStart()、onResume()都会执行。 2.2、singleTop 栈顶复用模式，启动的Activity位于栈顶时则会通过调用onNewItent()方法复用原来的Activity，不再创建一个新的实例。否则会像standard模式那样。一句话概述就是：当且仅当启动的 Activity 和上一个 Activity 一致的时候才会通过调用 onNewIntent() 方法重用 Activity 。使用场景：资讯阅读类 APP 的内容界面。 image.png 2.3 singleTask 栈内复用模式，当启动的Activity位于栈内时，就会通过调用onNewItent()方法复用当前的Activity，如果当前Activity上面还有其他Activity，同时会将其他Activity从栈内移出。如果栈内不存在当前Activity，则和standard模式一样。即： A -&gt;B -&gt; C -&gt; D -&gt; B，此时栈内变成了 A -&gt; B。而 A -&gt; B -&gt; C，栈内还是 A -&gt; B -&gt; C。使用场景：浏览器的主页面，或者大部分 APP 的主页面。 image.png 2.4 singleInstance 单实例模式，是一个加强版的singleTask，除了拥有singleTask的特性外，此种模式下Activity单独在一个任务栈中，依然是调用 onNewIntent() 方法。 image.png 到这里Activity启动模式就要说完了，其实还有一点与其相联系的知识，那就是Inent标签在 Android 中，我们除了在清单文件 AndroidManifest.xml 中配置 launchMode，当然可以用 Intent 标签说事儿。启动 Activity ，我们需要传递一个 Intent，完全可以通过设置 Intent.setFlags(int flags) 来设置启动的 Activity 的启动模式。 需要注意的是：通过代码来设置 Activity 的启动模式的方式，优先级比清单文件设置更高。 FLAG_ACTIVITY_NEW_TASK这个标识会使新启动的 Activity 独立创建一个 Task。 FLAG_ACTIVITY_CLEAR_TOP这个标识会使新启动的 Activity 检查是否存在于 Task 中，如果存在则清除其之上的 Activity，使它获得焦点，并不重新实例化一个 Activity，一般结合 FLAG_ACTIVITY_NEW_TASK 一起使用。 FLAG_ACTIVITY_SINGLE_TOP等同于在 launcherMode 属性设置为 singleTop。","tags":[{"name":"Android","slug":"Android","permalink":"http://suxianglun.github.io/tags/Android/"}]},{"title":"Android消息机制","date":"2017-10-30T03:15:04.000Z","path":"2017/10/30/Android消息机制/","text":"Android消息机制读了《Android开发艺术探索》中Android消息机制后对Android消息机制有了一个更深的理解，Android消息机制主要就是Handler运行机制。Handler运行机制需要MessageQueue、Looper来作为支撑。 1、MessageQueue工作原理MessageQueue即消息队列，主要进行两个操作：插入消息和读取消息，分别对应的方法是enqueueMessage()和next(),读取消息伴随着删除操作。MessageQueue命名为消息队列，其实内部却是使用单向链表的数据结构来维护消息队列的，单向链表在数据的插入和删除效率较高，具有优势。enqueueMessage()方法内部是对单链表的操作，next()方法内部是一个死循环，如果消息队列中没有消息，就一直阻塞在那里。 2、Looper工作原理Looper 在消息机制中起到消息循环的作用，Looper.prepare()获得当前线程的Looper对象，然后再通过Looper.loop()开启消息循环。除了prepare（）方法，Looper.prepareMainLooper()方法可以获取主线程的Looper,当然此方法也是通过prepare（）来实现的。Looper.getMainLooper()可以在任何地方获取主线程的Looper对象。Looper还可以退出，通过quit()和quitSafely()，二者区别是quit()是直接退出，quitSafely（）是先设定一个退出标记，然后将消息队列的中已有的消息都处理完后再退出。Looper退出后，Handler send消息时就会报错。Looper.loop()方法执行后才开启消息循环，loop（）方法是一个无限循环，直到MessageQueue.next()返回null时跳出循环。 3、Handler工作原理Handler主要就是进行消息的发送和接受，发送消息主要通过send的一系列方法和post的一系列方法，post方法也是通过send来实现的。Handler发送一条消息只是将该条数据插入Messagequeue中，Messagequeue的next()方法就会将这条消息返回给Looper,Looper收到消息后就开始处理了，最终Looper将消息交给Handler处理，即调用Handler的dispathMessage()。在dispathMessage()方法中先判断msg.callback是否为空，callback是一个Runnable对象，即handler的post()方法中Runnable,如果不为空就调用handleCallback()方法，然后在判断mCallback是否为空，不为空就调用mCallback的handleMessage()方法，mCallback是一个接口，创建Handler handler=new Handler（callback）时需要传一个callback。也就是说我们可以通过callback无须派生一个Handler子类就可以创建Handler，这样最终就调用handler的handMessage()方法。 4、Handler使用说明要想知道当前的Handler是哪个线程的Handler只需知道创建Handler时绑定的是哪个线程的Looper,如果创建的时候没有指定Looper，那就是主线程的Handler，因为只有主线程的Looper已经被获取，其他线程需要手动获取。还有一点就是，在哪个线程使用Handler的send或者post一系列方法，就是从当前Handler所在的线程给Handler本身所属的线程发消息。","tags":[{"name":"Android","slug":"Android","permalink":"http://suxianglun.github.io/tags/Android/"}]},{"title":"if __name__ == \"__main__\":是干嘛的?","date":"2017-08-16T04:46:17.000Z","path":"2017/08/16/name==main的作用/","text":"按照惯例先吟诗一首： 《宫词·故国三千里》–张祜故国三千里，深宫二十年。一声何满子，双泪落君前。 if name == “main“:是干嘛的?12345678910111213# Threading exampleimport time, threaddef myfunction(string, sleeptime, lock, *args): while 1: lock.acquire() time.sleep(sleeptime) lock.release() time.sleep(sleeptime)if __name__ == &quot;__main__&quot;: lock = thread.allocate_lock() thread.start_new_thread(myfunction, (&quot;Thread #: 1&quot;, 2, lock)) thread.start_new_thread(myfunction, (&quot;Thread #: 2&quot;, 2, lock)) 当Python解析器读取一个源文件时,它会执行所有的代码.在执行代码前,会定义一些特殊的变量.例如,如果解析器运行的模块(源文件)作为主程序,它将会把name变量设置成”main“.如果只是引入其他的模块,name变量将会设置成模块的名字. 假设下面是你的脚本,让我们作为主程序来执行: 1python threading_example.py 当设置完特殊变量,它就会执行import语句并且加载这些模块.当遇到def代码段的时候,它就会创建一个函数对象并创建一个名叫myfunction变量指向函数对象.接下来会读取if语句并检查name是不是等于”main“,如果是的话他就会执行这个代码段. 这么做的原因是有时你需要你写的模块既可以直接的执行,还可以被当做模块导入到其他模块中去.通过检查是不是主函数,可以让你的代码只在它作为主程序运行时执行,而当其他人调用你的模块中的函数的时候不必执行.","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"解决Python2.7的UnicodeEncodeError异常错误","date":"2017-08-16T04:37:55.000Z","path":"2017/08/16/解决Python2.7UnicodeEncodeError异常错误/","text":"按照惯例先吟诗一首: 12345 芙蓉楼送辛渐 (唐代：王昌龄) 寒雨连江夜入吴，平明送客楚山孤。 洛阳亲友如相问，一片冰心在玉壶。 1、解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误最近练习Python爬虫的时候遇到一个错误，先上解决错误前的代码1234567891011121314151617181920 # coding:utf-8import urllib2import sysfrom bs4 import BeautifulSoupimport unioutfrom quote import Quoteclass Xianqian: def __init__(self): self.url = &apos;http://www.juzimi.com/先秦&apos; self.headers = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&apos;&#125; def get_writer(self): # reload(sys) # sys.setdefaultencoding(&apos;utf-8&apos;) req = urllib2.Request(self.url, headers=self.headers, ) res = urllib2.urlopen(req) soup = BeautifulSoup(res.read(), &apos;html.parser&apos;) print soup 2、出现如下错误1UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 14-15: ordinal not in range(128) 3、分析原因：看了下异常信息，是因为编码问题：Unicode编码与ASCII编码的不兼容，其实这个Python脚本文件是由utf-8编码的,而Python默认环境编码是ascii编码方式，由此Python自然调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内，就会抛出异常（ordinal not in range(128)）。如果你不知道Python默认环境编码是什么，可以通过下面的方法可以获取: 123import sysprint sys.getdefaultencoding()# &apos;ascii&apos; 4、解决方案：通过sys.setdefaultencoding(‘utf-8)设置Python默认环境编码为utf-8，代码如下: 12import syssys.setdefaultencoding(‘utf-8) 但是运行之后出现了如下错误: 1AttributeError: &apos;module&apos; object has no attribute &apos;setdefaultencoding&apos; 意思是说sys没有setdefaultencoding()这个方法，其实是有的，只不过是先需要reload(sys) 123import sysreload(sys)sys.setdefaultencoding(&apos;utf-8&apos;) 这样就可以正常运行了修改后的代码如下: 123456789101112131415161718192021# coding:utf-8import urllib2import sysfrom bs4 import BeautifulSoupimport unioutfrom quote import Quoteclass Xianqian: def __init__(self): self.url = &apos;http://www.juzimi.com/&apos; self.headers = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&apos;&#125; def get_writer(self): reload(sys) sys.setdefaultencoding(&apos;utf-8&apos;) quote = Quote() req = urllib2.Request(self.url, headers=self.headers) res = urllib2.urlopen(req) soup = BeautifulSoup(res.read(), &apos;html.parser&apos;) print soup","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"python中range和xrange的区别","date":"2017-07-24T06:26:20.000Z","path":"2017/07/24/python中range和xrange的区别/","text":"按照惯例先吟诗一首： 《行宫》–元稹 寥落古行宫，宫花寂寞红。 白头宫女在，闲坐说玄宗。 range(start=None, stop=None, step=None)函数说明：12345Return a list containing an arithmetic progression of integers. range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0. When step is given, it specifies the increment (or decrement). For example, range(4) returns [0, 1, 2, 3]. The end point is omitted! These are exactly the valid indices for a list of 4 elements. 大致意思就是：range函数返回的是包含一个等差数列的整数列表，根据参数start与stop指定的范围以及step设定的差值，生成一个列表。 如果不指定step默认差值就是1，如果指定step，它指定递增(或递减)，差值就是step.如果不明白举个栗子，如果还不明白就举2个栗子。 例子1： 123a=range(0,10,2)print aprint type(a) 结果如下： 12[0, 2, 4, 6, 8]&lt;type &apos;list&apos;&gt; 例子2： 123a=range(0,-10,-2)print aprint type(a) 结果如下： 12[0, -2, -4, -6, -8]&lt;type &apos;list&apos;&gt; xrange 函数说明：和range 的用法完全相同，但是返回的是一个生成器。例子1： 123a=xrange(0,10,2)print aprint type(a) 结果如下： 12[xrange(0, 10, 2)&lt;type &apos;xrange&apos;&gt; 例子2： 123a=xrange(0,-10,-2)print aprint type(a) 结果如下： 12xrange(0, -10, -2)&lt;type &apos;xrange&apos;&gt; range和xrange区别：两个都是在循环迭代的时候使用，range返回的是个list,xrange返回的是xrange对象，生成很小的数字序列时候性能没什么区别，但是要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。如果你不是为了要返回一个list,在循环中尽量使用xrange。","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"Python PIL库安装","date":"2017-07-05T08:01:16.000Z","path":"2017/07/05/Python pIL库安装/","text":"按照惯例先吟诗一首 听筝唐代：李端鸣筝金粟柱，素手玉房前。欲得周郎顾，时时误拂弦。 由于需要使用Python操作图片，想使用sudo pip install PIL引入PIL(Python Imaging Library)库，但是结果如下： 12could not find a version that satisfies the requirement PIL.(form versions:)No matching distribution found for PIL. 这个提示很费解，只能去找度娘了，原来已经用Pillow代替了PIL，在使用方面没有不同，API都是相同的。真是个挨千刀的，提示信息里怎么不告诉我们这些刚学Python的小白呢，还得白忙活半天。既然这样那就老老实实安装Pillow吧。但是又发现Pillow需要依赖multiprocessing，所以必须先安装multiprocessing。命令如下: 1sudo pip install multiprocessing 接着再执行如下命令： sudo pip install Pillow 引入模块要按照下面的方式写（注意大小写）第一种：from PIL import Image第二种：from PIL.Image(用这种方式时，下面使用时也得写成PIL.Image.open(‘1.png’)，或者可以在引入时修改下模块名，如from PIL.Image as image) 引入之后就可以正常使用了。","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"Java线程常用方法之join()","date":"2017-06-01T08:10:06.000Z","path":"2017/06/01/Java线程常用方法之join()/","text":"按照惯例先吟诗一首： 送崔九唐代：裴迪归山深浅去，须尽丘壑美。莫学武陵人，暂游桃源里。 join()方法的作用是等待线程销毁。例如在main线程新起一个子线程，子线程需要做一些耗时造作，main线程想要得到子线程执行完成的数据，就必须等到执行完子线程再去执行，这时候就可以用join来解决。 基本使用下面用代码来说明： MyThread类 1234567891011121314class MyThread04 extends Thread&#123; @Override public void run() &#123; try&#123; int value=(int)(Math.random()*1000); System.out.println(&quot;thread04 value=&quot;+value); Thread.sleep(value); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; YieldTest类 12345678910111213public class JoinTest &#123; public static void main(String[] args)&#123; MyThread04 thread04=new MyThread04(); thread04.start();// try &#123;// thread04.join();// &#125;catch (InterruptedException e)&#123;// e.printStackTrace();// &#125; System.out.println(&quot;我想在thread04之后执行&quot;); &#125;&#125; 结果如下： 我想在thread04之后执行thread04 value=8 从结果上看，主线程和子线程是异步的，并没有在子线程执行完之后才执行，而是在子线程执行过程中就执行了主线程。如果想要实现同步的话，需要用到join()方法 将MyThread03类更改一下 1234567891011121314public class JoinTest &#123; public static void main(String[] args)&#123; MyThread04 thread04=new MyThread04(); thread04.start(); try &#123; thread04.join(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;我想在thread04之后执行&quot;); &#125;&#125; 结果如下： thread04 value=323我想在thread04之后执行","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Java线程常用方法之yield()","date":"2017-06-01T07:41:19.000Z","path":"2017/06/01/Java线程常用方法之yield()/","text":"按照惯例先吟诗一首： 杂诗唐代：王维君自故乡来，应知故乡事。来日绮窗前，寒梅著花未？ yield()方法的作用是让当前线程放弃当前cup资源，让其他任务获取cup资源。但放弃的时间不确定，有可能放放弃又马上获取cpu资源。 基本使用下面用代码来说明： MyThread类 1234567891011121314class MyThread03 extends Thread&#123; @Override public void run() &#123; long beginTime=System.currentTimeMillis(); int count=0; for (int i=0;i&lt;50000000;i++)&#123;// Thread.yield(); count=count+(i+1); &#125; long endTime=System.currentTimeMillis(); System.out.println(&quot;用时=&quot;+(endTime-beginTime)+&quot;毫秒&quot;); &#125;&#125; YieldTest类 1234567public class YieldTest &#123; public static void main(String[] args)&#123; MyThread03 thread03=new MyThread03(); thread03.start(); &#125;&#125; 结果如下： 用时=23毫秒 将MyThread03类更改一下 1234567891011121314class MyThread03 extends Thread&#123; @Override public void run() &#123; long beginTime=System.currentTimeMillis(); int count=0; for (int i=0;i&lt;50000000;i++)&#123; Thread.yield(); count=count+(i+1); &#125; long endTime=System.currentTimeMillis(); System.out.println(&quot;用时=&quot;+(endTime-beginTime)+&quot;毫秒&quot;); &#125;&#125; 结果如下： 用时=10552毫秒","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Java线程常用方法之sleep()","date":"2017-06-01T07:25:55.000Z","path":"2017/06/01/Java线程常用方法之sleep() /","text":"按照惯例先吟诗一首： 山中送别唐代：王维山中相送罢，日暮掩柴扉。春草明年绿，王孙归不归？ sleep()方法的作用是在指定的毫秒数中让当前运行的线程休眠，当前的线程指的是this.currentTread() 基本使用下面用代码来说明： MyThread类 1234567891011121314class MyThread02 extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println(&quot;Thread name:&quot;+Thread.currentThread().getName()+&quot;begin=&quot;+System.currentTimeMillis()); Thread.sleep(2000); System.out.println(&quot;Thread name:&quot;+Thread.currentThread().getName()+&quot;end=&quot;+System.currentTimeMillis()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; SleepTest类 123456789public class SleepTest &#123; public static void main(String[] args)&#123; MyThread02 thread02=new MyThread02(); System.out.println(&quot;Begin&quot;); thread02.start(); System.out.println(&quot;end&quot;); &#125;&#125; 结果如下： BeginendThread name:Thread-0begin=1496281723821Thread name:Thread-0end=1496281725822","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Java线程常用方法之isAlive()","date":"2017-05-27T08:49:30.000Z","path":"2017/05/27/Java线程常用方法之isAlive()/","text":"按照惯例先吟诗一首： 《春怨 / 伊州歌》唐代：金昌绪打起黄莺儿，莫教枝上啼。啼时惊妾梦，不得到辽西。 这篇主要来了解一下isAlive()方法，此方法返回当前线程是否处于“活动状态”，何为“活动状态”，线程已经启动尚未终止。 基本使用下面用代码来说明： MyThread类 12345678class MyThread01 extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;Name:&quot;+Thread.currentThread().getName()); System.out.println(&quot;state:&quot;+Thread.currentThread().isAlive()); &#125;&#125; IsAliveTest类 12345678public class IsAliveTest &#123; public static void main(String [] args)&#123; MyThread01 thread01=new MyThread01(); System.out.println(&quot;begin:&quot;+thread01.isAlive()); thread01.start(); System.out.println(&quot;end:&quot;+thread01.isAlive()); &#125;&#125; 结果如下： begin:falseend:trueName:Thread-0state:true 将IsAliveTest类改为如下： 12345678910111213public class IsAliveTest &#123; public static void main(String [] args)&#123; MyThread01 thread01=new MyThread01(); System.out.println(&quot;begin:&quot;+thread01.isAlive()); thread01.start(); try &#123; Thread.sleep(1000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;end:&quot;+thread01.isAlive()); &#125;&#125; 结果如下： begin:falseName:Thread-0state:trueend:false 调用Thread.sleep(1000)让主线程休眠1秒，在这1秒内Thread-0线程已经执行完毕，再调用isAlive()时返回false","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Java线程常用方法之currentThread（）","date":"2017-05-27T08:35:30.000Z","path":"2017/05/27/Java线程常用方法之currentThread()/","text":"Java线程中有很多常用的方法，需要花费一些时间来理解，今天就先来学习一下currentThread（）方法。currentThread（）方法返回调用此代码段的线程信息，其中可以通过 Thread.currentThread().getId()获取当前线程idThread.currentThread().getName()获取当前线程nameThread.currentThread().getPriority()获取当前线程优先级 下面用代码来说明： MyThread类 12345678910class MyThread extends Thread&#123; public MyThread()&#123; System.out.println(&quot;构造方法中打印的线程名字：&quot;+Thread.currentThread().getName()); &#125; @Override public void run() &#123; System.out.println(&quot;run方法中打印的线程名字：&quot;+Thread.currentThread().getName()); &#125;&#125; CurrentThreadTest类 1234567891011public class CurrentThreadTest &#123; public static void main(String[ ]args)&#123; Thread thread=new MyThread(); thread.start();// thread.run(); &#125;&#125; 结果如下： 构造方法中打印的线程名字：mainrun方法中打印的线程名字：Thread-0 说明MyThread类的构造方法被main线程调用的，run方法是自动调用的方法。 将CurrentThreadTest类改为如下： 1234567891011public class CurrentThreadTest &#123; public static void main(String[ ]args)&#123; Thread thread=new MyThread();// thread.start(); thread.run(); &#125;&#125; 结果如下： 构造方法中打印的线程名字：mainrun方法中打印的线程名字：main 说明MyThread类的构造方法被main线程调用的，run方法是被main线程调用的。","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Java线程的五种状态","date":"2017-05-26T09:34:36.000Z","path":"2017/05/26/Java线程的状态 /","text":"按照惯例先吟诗一首： 送上人唐代：刘长卿孤云将野鹤，岂向人间住。莫买沃洲山，时人已知处。 什么是线程：一个线程是进程的一个顺序执行流。同类的多个线程共享一块内存空间和一组系统资源，一个进程中可以包含多个线程。 进程与线程的区别一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程状态 新建状态当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。 就绪状态个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。 处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序来调度的。 运行状态（Running）当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法。 阻塞状态（blocked）线程运行过程中，可能由于各种原因进入阻塞状态： ①线程通过调用sleep方法进入睡眠状态； ②线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者； ③线程试图得到一个锁，而该锁正被其他线程持有； ④线程在等待某个触发条件； 所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。 死亡状态有两个原因会导致线程死亡： ①run方法正常退出而自然死亡； ②一个未捕获的异常终止了run方法而使线程猝死； 为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法，如果是可运行或被阻塞，这个方法返回true；如果线程仍旧是new状态且不是可运行的，或者线程死亡了，则返回false。","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"Kotlin中val 和var的区别","date":"2017-05-24T07:25:28.000Z","path":"2017/05/24/Kotlin中val 和var的区别/","text":"按照惯例先吟诗一首 静夜思唐代：李白床前明月光，疑是地上霜。举头望明月，低头思故乡。 前几天朋友圈刷爆了关于Kotlin成为Android官方语言的新闻，为了体验一下，开始学习Kotlin的基础语法。其中Kotlin中有两个关键字定义变量var和val,区别如下： var： var是一个可变变量，这是一个可以通过重新分配来更改为另一个值的变量。这种声明变量的方式和Java中声明变量的方式一样。val: val是一个只读变量，这种声明变量的方式相当于java中的final变量。一个val创建的时候必须初始化，因为以后不能被改变。 上段代码体验一下： var name = &quot;lao wang&quot; println(name) name = &quot;xiao wang&quot; println(name) val finalValue = &quot;我万年不变的老李&quot;; println(finalValue); 结果如下： lao wangxiao wang我万年不变的老李","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://suxianglun.github.io/tags/Kotlin/"}]},{"title":"flask_restful安装遇到的问题","date":"2017-05-15T09:40:16.000Z","path":"2017/05/15/安装 Flask-RESTful遇到的问题/","text":"按照惯例先吟诗一首： 《登乐游原》–李商隐向晚意不适，驱车登古原。夕阳无限好，只是近黄昏。 1.使用 pip 安装 Flask-RESTful: pip install flask-restful 使用pip安装第三方库总是提示：You are using pip version 8.0.2, however version 8.1.0 is available 且输入“python -m pip install -U pip”升级pip版本命名还是报同样的错误。 解决办法： 第一步：使用PyCharm，选择file→Setting，找到pip 双击 第二步：按照图片，点击pip，勾选specify version，然后点击 install package 第三步：如果安装出现连接不成功，请使用VPN； 如果出现报错：“UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xd7 in position 9: ordinal not in range(128)”请修改mimetypes.py文件，路径位于python的安装路径下的Lib\\mimetypes.py文件。在import下添加如下几行： 123if sys.getdefaultencoding() != &apos;gbk&apos;: reload(sys) sys.setdefaultencoding(&apos;gbk&apos;) 然后重复第二步操作，安装即可。 注意：其实也可以直接执行第三步，直接修改mimetypes.py文件的信息，然后输入pip升级命令“python -m pip install -U pip” 2.安装过程中遇到的第二个问题：Permission denied: ‘/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/dateutil’ 这里是因为权限问题，需要使用sudo安装，键入如下代码安装： 1sudo pip install flask-restful","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"Java关键字this的使用","date":"2017-05-11T02:44:15.000Z","path":"2017/05/11/Java关键字this的使用/","text":"按照惯例先吟诗一首： 《八阵图》–杜甫功盖三分国，名成八阵图。江流石不转，遗恨失吞吴。 1.成员变量和局部变量重名时，在方法中使用this时，this代表的是该方法所在类的成员变量。123456789101112131415 public class Hello &#123; String s = &quot;Hello&quot;; public Hello(String s) &#123; System.out.println(&quot;s = &quot; + s); System.out.println(&quot;1 -&gt; this.s = &quot; + this.s); this.s = s;//把参数值赋给成员变量，成员变量的值改变 System.out.println(&quot;2 -&gt; this.s = &quot; + this.s); &#125; public static void main(String[] args) &#123; Hello x = new Hello(&quot;HelloWorld!&quot;); System.out.println(&quot;s=&quot; + x.s);//验证成员变量值的改变 &#125;&#125; 结果为： s = HelloWorld! 1 -&gt; this.s = Hello 2 -&gt; this.s = HelloWorld! s=HelloWorld! 2.把自己当作参数传递时，也可以用this.(this作当前参数进行传递)1234567891011121314151617181920212223242526class A &#123; public A() &#123; new B(this).print();// 调用B的方法 &#125; public void print() &#123; System.out.println(&quot;HelloAA from A!&quot;); &#125;&#125;class B &#123; A a; public B(A a) &#123; this.a = a; &#125; public void print() &#123; a.print();//调用A的方法 System.out.println(&quot;HelloAB from B!&quot;); &#125;&#125;public class HelloA &#123; public static void main(String[] args) &#123; A aaa = new A(); aaa.print(); B bbb = new B(aaa); bbb.print(); &#125;&#125; 结果为：HelloAA from A!HelloAB from B!HelloAA from A!HelloAA from A!HelloAB from B! 3．有时候，我们会用到一些内部类和匿名类，如事件处理。当在匿名类中用this时，这个this则指的是匿名类或内部类本身。这时如果我们要使用外部类的方法和变量的话，则应该加上外部类的类名。123456789101112131415161718192021222324252627public class HelloB &#123; int i = 1; public HelloB() &#123; Thread thread = new Thread() &#123; public void run() &#123; for (int j=0;j&lt;20;j++) &#123; HelloB.this.run();//调用外部类的方法 try &#123; sleep(1000); &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; &#125;; // 注意这里有分号 thread.start(); &#125; public void run() &#123; System.out.println(&quot;i = &quot; + i); i++; &#125; public static void main(String[] args) throws Exception &#123; new HelloB(); &#125;&#125; thread 是一个匿名类对象，在它的定义中，它的 run 函数里用到了外部类的 run 函数。这时由于函数同名，直接调用就不行了。这时有两种办法，一种就是把外部的 run 函数换一个名字，但这种办法对于一个开发到中途的应用来说是不可取的。那么就可以用这个例子中的办法用外部类的类名加上 this 引用来说明要调用的是外部类的方法 run。 4.在构造函数中，调用本类的另一个构造函数。可以使用this调用12345678910111213141516171819public class ThisTest &#123; private int age; private String str; ThisTest(String str) &#123; this.str=str; System.out.println(str); &#125; ThisTest(String str,int age) &#123; this(str); this.age=age; System.out.println(age); &#125; public static void main(String[] args) &#123; ThisTest thistest = new ThisTest(&quot;this测试成功&quot;,25); &#125;&#125; 结果为：this测试成功25 值得注意的是： 1：在构造函数中调用另一个构造函数，调用动作必须置于最起始的位置。 2：不能在构造函数以外的任何函数内调用构造函数。 3：在一个构造函数内只能调用一个构造函数。 4：不能通过this递归调用构造方法，即不能在一个构造方法中通过this直接或间接调用该构造方法本身。 5．this同时传递多个参数。123456789101112131415161718public class TestClass &#123; int x; int y; static void showtest(TestClass tc) &#123;//实例化对象 System.out.println(tc.x + &quot; &quot; + tc.y); &#125; void seeit() &#123; showtest(this); &#125; public static void main(String[] args) &#123; TestClass p = new TestClass(); p.x = 9; p.y = 10; p.seeit(); &#125;&#125; 6.super和this的异同super在一个类中用来引用其父类的成员，它是在子类中访问父类成员的一个桥梁，并不是任何一个对象的引用，而this则表示当前类对象的引用。在代码中Object o = super;是错误的，Object o = this;则是允许的。super关键字的作用在于当子类中覆盖了父类的某个成员变量，或者重写了父类的某个成员方法时还能够访问到父类的成员变量和成员方法。如果子类中没有重写父类的成员变量和成员方法，则子类会继承父类的所有非private的成员变量和成员方法。这时在子类中无论通过this来访问成员和通过super来访问成员，结果都是一样的。 super.getClass()和this.getClass()getClass()是Object类定义的一个final方法，所有Java类的getClass()都继承自Object类。如前文所述，如果子类没有重写父类的某个成员方法，那么通过super来访问还是还是通过this来访问结果都是一样的。因此，super.getClass()和this.getClass()结果是一样的。Object类的getClass()方法返回的是该对象的运行时类，一个对象的运行时类是该对象通过new创建时指定的类。因此，super.getClass()和this.getClass()返回的都是new对象时指定的类。","tags":[{"name":"Java","slug":"Java","permalink":"http://suxianglun.github.io/tags/Java/"}]},{"title":"《Python核心编程》学习笔记03（Python对象）","date":"2017-05-05T08:52:32.000Z","path":"2017/05/05/Python核心编程》学习笔记03（Python对象）/","text":"按照惯例先吟诗一首： 宿建德江唐代：孟浩然移舟泊烟渚，日暮客愁新。野旷天低树，江清月近人。 1.标准类型内建函数1.type()type()接受一个对象参数，返回该对象的类型。它的返回值是一个对象的类型。 12&gt;&gt;&gt; type(4) # int type &lt;type &apos;int&apos;&gt; 2.cmp()内建函数cmp(obj1,obj2)用来比较两个对象obj1和obj2的大小，如果obj1比obj2小的话，返回负整数，如果obj1比obj2大的话，返回正整数，如果obj1等于obj2小的话，返回0，比较是在对象之间进行的，不管是标准类型对象还是用户自定 义对象。如果是用户自定义对象， cmp()会调用该类的特殊方法cmp() 1234567&gt;&gt;&gt; a, b = -4, 12 &gt;&gt;&gt; cmp(a,b) -1 &gt;&gt;&gt; cmp(b,a) 1 &gt;&gt;&gt; b = -4 &gt;&gt;&gt; cmp(a,b) 0 &gt;&gt;&gt; &gt;&gt;&gt; a, b = &apos;abc&apos;, &apos;xyz&apos; &gt;&gt;&gt; cmp(a,b) -23 &gt;&gt;&gt; cmp(b,a) 23 &gt;&gt;&gt; b = &apos;abc&apos; &gt;&gt;&gt; cmp(a,b) 0 3.str()和 repr() (及 `` 运算符)str()函数得到的字符串可读性好， 而 repr()函数得到的字符 串通常可以用来重新获得该对象, 通常情况下 obj == eval(repr(obj)) 这个等式是成立的。事实上 repr() 和 “” 做的 是完全一样的事情，它们返回的是一个对象的“官方”字符串表示，但 str()则有所不同。str() 致力 于生成一个对象的可读性好的字符串表示，它的返回结果通常无法用于 eval()求值， 但很适 合用于 print 语句输出。 4.type() 和 isinstance()在Python中可以使用type()与isinstance()这两个函数判断对象类型，而isinstance()函数的使用上比type更加方便。区别就是 对于subclass之类的 type就不行了，所以,强烈建议不要使用type判断对象类型。 12345678910 class A: passclass B(A): passisinstance(A(), A) # returns Truetype(A()) == A # returns Trueisinstance(B(), A) # returns Truetype(B()) == A # returns False 2.标准类型分布 数据类型 存储模型 更新模型 访问模型 数字 标量 不可变 直接访问 字符串 标量 不可变 顺序访问 列表 容器 可变 顺序访问 元祖 容器 不可变 顺序访问 字典 容器 可变 映射访问","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"《Python核心编程》学习笔记02（Python基础）","date":"2017-05-05T07:25:11.000Z","path":"2017/05/05/《Python核心编程》学习笔记02（Python基础）/","text":"按照惯例先吟诗一首： 《哥舒歌》–西鄙人北斗七星高，哥舒夜带刀。至今窥牧马，不敢过临洮。 1.模块结构和布局合理的布局结构应该如下： 1、起始行：通常只有在类 Unix 环境下才使用起始行，有起始行就能够仅输入脚本名字来执行脚本，无需直接调用解释器。 2、模块文档：简要介绍模块的功能及重要全局变量的含义,模块外可通过 module.doc 访问这些内容。 3、模块导入：导入当前模块的代码需要的所有模块;每个模块仅导入一次(当前模块被加载时);函数内部的模块导入代码不会被执行， 除非该函数正在执行。 4、定义变量：这里定义的变量为全局变量，本模块中的所有函数都可直接使用。从好的编程风格角度说， 除非必须，否则就要尽量使用局部变量代替全局变量，如果坚持这样做，你的代码就不但容易维护，而且还可以 高性能并节省内存。 5、类定义语句：所有的类都需要在这里定义。当模块被导入时 class 语句会被执行, 类也就会被定义。类 的文档变量是 class.doc。 6、方法语句： 此处定义的函数可以通过 module.function()在外部被访问到，当模块被导入时 def 语句 会被执行， 函数也就都会定义好，函数的文档变量是 function.doc。 7、主程序：无论这个模块是被别的模块导入还是作为脚本直接执行，都会执行这部分代码。通常这里 不会有太多功能性代码，而是根据执行的模式调用不同的函数。 2. _ name _ 指示模块应如何被加载由于主程序代码无论模块是被导入还是被直接执行都会运行，我们必须知道模块如何决定 运行方向。一个应用程序可能需要导入另一个应用程序的一个模块，以便重用一些有用的代码 (否则就只能用拷贝粘贴那种非面向对象的愚蠢手段)。这种情况下，你只想访问那些位于其 它应用程序中的代码，而不是想运行那个应用程序。因此一个问题出现了，“Python 是否有 一种方法能在运行时检测该模块是被导入还是被直接执行呢?” 答案就是……(鼓声雷动)…..没错! name 系统变量就是正确答案。 如果模块是被导入， _ name 的值为模块名字如果模块是被直接执行， name 的值为 ‘ main _’ 3.变量和内存管理细节主要包含以下几点： 1、变量无须提前声明2、变量无须制定类型类型3、程序员无须关心内存管理4、变量会被收回5、del 语句能够直接释放资源","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"《Python核心编程》学习笔记01（Python起步）","date":"2017-05-04T05:52:13.000Z","path":"2017/05/04/python核心编程学习笔记01（Python起步）/","text":"按照惯例先吟诗一首： 江雪唐代：柳宗元千山鸟飞绝，万径人踪灭。孤舟蓑笠翁，独钓寒江雪。 1.程序输出print语句及“HelloWorld!”12345&gt;&gt;&gt; myString = &apos;Hello World!&apos; &gt;&gt;&gt; print myString &apos;Hello World!&apos;&gt;&gt;&gt; myString &apos;Hello World!&apos; 1.1._ 和 %在print中的使用下划线(_)在解释器中有特别的含义，表示最后一个表达式的值。所以上面的代码执行之后， 下划线变量会包含字符串: 12&gt;&gt;&gt; _Hello World! Python的print语句，与字符串格式运算符( %)结合使用，可实现字符串替换功能。%s 表示由一个字符串来替换，而%d 表示由一个整数来替换，另外一个很常用的就是%f。它表示由一个浮点数来替换。 12&gt;&gt;&gt; print ‘%s is number %d !’ % (&apos;python&apos;, 1)python is number 1! 2.程序输入和内建函数raw_input()从用户那里得到数据输入的最容易的方法是使用 raw_input()内建函数。它读取标准输入，并将读取到的数据赋值给指定的变量。 12&gt;&gt;&gt; user=raw_input(&apos;henter your name: &apos;)enter your name suxianglun 内建函数 int()将数值字符串转换成整数值，这样才可以对它进行数学运算 1234&gt;&gt;&gt; num = raw_input(&apos;Now enter a number: &apos;)Now enter a number: 1024 &gt;&gt;&gt; print &apos;Doubling your number: %d&apos; % (int(num) * 2) Doubling your number: 2048 3.使用help()函数获取帮助信息help()在交互式解释器中获取帮助信息,在学习 Python 的过程中，如果需要得到一个生疏函数的帮助，只需要对它调用内建函数help()。通过用函数名作为 help()的参数就能得到相应的帮助信息,查看结束退出使用 ：wq进行退出 123&gt;&gt;&gt; help(raw_input)Help on built-in function raw_input in module __builtin__:raw_input(...) raw_input([prompt]) -&gt; string 4. 列表解析表示可以在一行中使用for循环将所得到的的值放在列表中 12&gt;&gt;&gt; squared = [x ** 2 for x in range(4)] &gt;&gt;&gt; for i in squared: ... print i 0 1 4 9 列表解析可以做更复杂的事情 1234567&gt;&gt;&gt;squared = [x ** 2 for x in range(8) if not x%2]&gt;&gt;&gt;for i in squared...print i041636 5.实用的函数 函数 描述 dir([obj]) 显示对象的属性，如果没有提供参数， 则显示全局变量的名字 help([obj]) 以一种整齐美观的形式 显示对象的文档字符串， 如果没有提供任何参 数， 则会进入交互式帮助。 int(obj) 将一个对象转换为整数 len(obj) 返回对象的长度 open(fn, mode) 以 mode(‘r’ = 读， ‘w’= 写)方式打开一个文件名为 fn 的文件 range([[start,]stop[,step]) 返回一个整数列表。起始值为 start, 结束值为 stop - 1; start 默认值为 0， step默认值为1。 raw_input(str) 等待用户输入一个字符串， 可以提供一个可选的参数 str 用作提示信 息。 str(obj) 将一个对象转换为字符串 type(obj) 返回对象的类型(返回值本身是一个 type 对象!)","tags":[{"name":"Python","slug":"Python","permalink":"http://suxianglun.github.io/tags/Python/"}]},{"title":"URI和URL含义及其理解","date":"2017-04-28T08:14:03.000Z","path":"2017/04/28/URL和URI含义及理解/","text":"按照惯例先吟诗一首： &lt;&lt;相思&gt;&gt; –王维 红豆生南国，春来发几枝。 愿君多采撷，此物最相思。 1、URI和URL含义：在理解URL之前先来看一下什么是URI 1.1 什么是URI？简单点说：URI就是通用资源标志符，不理解是吧，我第一次听说也是不理解。进一步说：网络上的一些资源（文档、图片、音频、视频、程序等）都是有一些通用资源标识（Universal Resource Identifier， URI）进行定位的。也就是说如果你想要在网络上找到特定的这些资源，只需知道他们的URI，就可以进行定位，从而找到他们。 通常情况下URI由三部分组成： 1、访问资源的命名机制2、存放资源的主机名3、资源自身的名称，由路径表示 如下面的URI：http://www.jianshu.com/writer#/notebooks/9212154http://可以这样解读： 1、以http机制访问资源2、存在以www.jianshu.com为名的主机上3、资源路径为notebooks/9212154http:// 1.2什么是URLURL是URI的子集，它是Uniform Resource Locator的缩写，统一资源定位符”。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL的格式由三部分组成： ①第一部分是协议(或称为服务方式)。②第二部分是存有该资源的主机IP地址(有时也包括端口号)。③第三部分是主机资源的具体地址，如目录和文件名等。第一部分和第二部分用“://”符号隔开，第二部分和第三部分用“/”符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。 2、URL和URI的区别 URI的定义是：统一资源标识符；URL的定义是：统一资源定位符。URI属于URL更低层次的抽象，一种字符串文本标准。换句话说，URI属于父类，而URL属于URI的子类。URL是URI的一个子集。URI属于URL更低层次的抽象，一种字符串文本标准。换句话说，URI属于父类，而URL属于URI的子类。URL是URI的一个子集。","tags":[{"name":"Web","slug":"Web","permalink":"http://suxianglun.github.io/tags/Web/"}]},{"title":"如何利用Hexo、GitHub pages从零开始创建个人博客","date":"2017-04-19T01:19:42.000Z","path":"2017/04/19/howCreateMyBlog/","text":"按照惯例先吟诗一首： 《竹里馆》–王维独坐幽篁里，弹琴复长啸。深林人不知，明月来相照。 从搭建到成功以及本文的诞生，前后花了两天时间，真是一把辛酸泪，感觉还是挺费事的，中途一度想放弃，可还是咬牙坚持下来了，但看到结果后感觉一切的辛苦都是值得的。过程中一定要有耐心，毕竟需要用到的东西挺多的，比如：node.js、git、 github、hexo其中的知识。废话不多说了，详情如下： 一、系统环境配置：要想利用Hexo、GitHub搭建个人博客，首先要安装Node.js、git： 1、Node.js安装：下载Node.js 或者通过如下命令安装： brew install node #最新版的node.js的包中已经集成了npm包管理工具 通过如下命令查看是否安装成功： node -vnpm -v 2、Git安装及配置：下载Git 或者通过如下命令安装： brew install git #Mac电脑使用brew安装sudo apt-get install git #Ubuntu系统使用这条命令安装 配置详见另外一篇博客： git安装与配置 3、Hexo安装： $ npm install hexo -g #-g表示全局安装, npm默认为当前项目安装 如遇错误，请使用一下安装： $ npm install hexo –no-optional 验证是否成功安装： $ hexo -v 目前我用到的环境如下 ，出现类似如下环境说明hexo安装成功 hexo-cli: 1.0.2os: Darwin 16.4.0 darwin x64http_parser: 2.7.0node: 6.10.0v8: 5.1.281.93uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 58.2modules: 48openssl: 1.0.2k 创建博客的根目录并切换到更目录下： $ mkdir myblog$ cd myblog 初始化myblog文件夹使其成为Hexo博客： $ hexo init 自动根据当前目录下文件,生成静态网页： $ hexo generate 运行本地服务： $ hexo server 有必要提下Hexo常用的几个命令： $ hexo new “postName” #新建文章$ hexo new page “pageName” #新建页面$ hexo generate (或者hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹$ hexo server (或者hexo s) 启动本地web服务，用于博客的预览$ hexo deploy (或者hexo d) 部署播客到远端（比如github, coding等平台） 常用简写： $ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy 常用组合： $ hexo d -g #生成部署$ hexo s -g #生成预览 通过hexo g生成静态文件和hexo s启动本地web服务后，现在我们打开http://localhost:4000/ 就可以看到一篇内置的blog了。看到后是不是感觉很有成就感？反正我是这么认为的。 二、Hexo主题设置默认的主题是landscape，这里以主题yilia为例进行说明。Hexo中文官网：下载主题、配置详解 安装主题 $ hexo clean$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改主题 修改myblog目录下的_config.yml配置文件中的theme属性，将其设置为yilia。并按照主题说明进行相关的配置，这点很重要，否则修改后的主题样式会有变化例如：git clone https://github.com/GeekaholicLin/hexo-theme-ylion.git这个主题就需要在_config.yml配置文件添加如下内容： search插件基于 https://github.com/PaicHyperionDev/hexo-&gt;generator-search使用说明请参考该reposearch: path: search.xml field: all 更新主题 $ hexo g # 生成$ hexo s # 启动本地web服务器 三、GitHub Pages配置1、注册、登录GitHubgithub官网：https://github.com/ 你值得拥有 2、创建项目仓库注册并登陆Github官网成功后，点击页面右上角的+，选择New repository。 你值得拥有 3、填写项目名在Repository name中填写：Github账号名.github.io 必须这样填，否则会出错 例如我的账号为:allen,那么就必须填allen.github.io 你值得拥有 4、设置GitHub pages打开settings，有一个Github Pages 的设置，点击 source 中的本来的 None ，使其变成 master 分支，也就是作为部署github pages 的分支，然后点击 save。 你值得拥有 5、查看网址页面刷新之后，再看 github pages 设置框处，多了一行网址，就是你的 github pages 的网址了，点击进去就进入属于你自己的博客网址了。 你值得拥有 四、部署到GitHub pages1、修改_config.yml千万要注意冒号：后边要留有空格 基本设置 title: allensubtitle: welcome to allen blogdescription:author: John Doelanguage: zh-CN #语言timezone: #时区 URLIf your site is put in a subdirectory, set url as ‘http://yoursite.com/child‘ and root as ‘/child/‘ url: http://suxianglun.github.io #用于绑定域名, 其他的不需要配置，即为GitHub pages生成的那个网址root: /permalink: :year/:month/:day/:title/permalink_defaults: ExtensionsPlugins: https://hexo.io/plugins/Themes: https://hexo.io/themes/theme: hexo-theme-landfarz #主题设置 DeploymentDocs: https://hexo.io/docs/deployment.htmldeploy: #部署, 发布在 GitHub 上面 type: git repo: git@github.com:suxianglun/suxianglun.github.io.git #GitHub 项目仓库 branch: master 2、部署到GitHub 上 $ hexo clean #清除$ hexo g #生成$ hexo d #部署 # 可与hexo g合并为 hexo d -g $ hexo d 之后如果出现ERROR Deployer not found: Git,请键入如下命令 $ npm install hexo-deployer-git –save 部署之后去查看GitHub pages那个网址http://suxianglun.github.io，有可能会出现:Your site is having problems building: unable to build page. Please try again later. 或者Your page is having problems building: page build failed同时也会收到github发来的page build failure的邮件，但是邮件中显示的错误信息和settings页面上的一样, 就这句话, 什么都没有, 没有任何错误提示.我就卡在这一天，后来用了好长时间来解决了。我分析的主要原因如下：1、Hexo未进行构建html,即未执行hexo g,这个过程需要一段时间，构建好html后myblog根目录下完整目录应该如下： README.md db.json package.json scaffolds themes_config.yml node_modules public source 2、Hexo 配置不正确，请严格按照要求进行配置 注意事项：markdown标题标准写法写法需要在”#”和后面字符之间加一个空格如果不加空格 有些引擎就解析不了 另外说一下我的个人博客地址 https://suxianglun.github.io/ 欢迎来骚扰。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://suxianglun.github.io/tags/Hexo/"}]},{"title":"Android studio下JNI开发","date":"2017-04-05T03:11:48.000Z","path":"2017/04/05/Android studio下JNI和NDK开发/","text":"按照惯例先吟诗一首： 《登鹳雀楼》–王之涣白日依山尽，黄河入海流。欲穷千里目，更上一层楼。 1.下载Ndk并配置点菜单栏的File-&gt;ProjectStructure…-&gt;在打开的窗口中左侧选中SDKLocation-&gt;在右侧Android NDK Location中填入NDK目录所在路径，如下图所示： 2. 新建项目JniDemo1. 新建类JniUtil,声明所需要的native方法：getJniAdd(int a,int b),代码如下:public class JniUtil { static { System.loadLibrary(&quot;JniUtil&quot;); } public static native int getJniAdd(int a, int b); } 2. 生成Java文件中native方法相对应的jin层c代码接口在AS界面的Terminal窗口中执行命令：cd app/src/main/java定位至java文件夹，然后再执行命令：javah -jni com.richsoft.jnidemo.JniUtil注意”com.richsoft.jnidemo”是JniUtil所在的包名。此时在app/src/main/java路径下生成了一个.h文件，如图： 3.新建jni文件夹app-&gt;new-&gt;Floder-&gt;JNI Folder,如下图： 点击之后弹出选择框： 点击finish之后，main文件夹下生成jni文件夹，如下图： 4.实现项目中声明的Native方法在jni目录下创建JniUtil.c文件,然后将com_richsoft_jnidemo_JniUtil.h中的方法拷贝至JniUtil.c中，并实现这个方法，如下代码： #include&lt;jni.h&gt; JNIEXPORT jint JNICALL Java_com_richsoft_jnidemo_JniUtil_getJniAdd (JNIEnv *env, jclass cls, jint a, jint b) { return a + b; } 3.编译.so文件1.gradle内添加代码：在gradle.properties文件末尾添加上“android.useDeprecatedNdk=true”然后在app文件下build.grade－&gt;defaultConfig括号内添加如下代码： ndk { moduleName &quot;JniUtil&quot; //生成的so名字 abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot; ,&quot;x86&quot;//输出指定三种abi体系结构下的so库，目前可有可无。 } 2.build 项目点击Build下的Make Project,成功之后打开app-&gt;intermediates-&gt;ndk-&gt;debug发现了四个文件夹,如下图： 到此，生成.so文件的过程结束。在src\\main下新建jniLibs文件夹，将上面的四个文件夹拷贝至jniLibs文件夹下，如图： 将jni文件夹和.h文件删除，如下图： 最后咱们试试生成的.so文件能不能用，贴下MainActivity代码： public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tv = (TextView) findViewById(R.id.tv); tv.setText(&quot;java调用C语言实现的加法运算:2+1000=&quot; + JniUtil.getJniAdd(2, 10000)); } } 运行下程序，结果如下：","tags":[{"name":"Android","slug":"Android","permalink":"http://suxianglun.github.io/tags/Android/"}]}]