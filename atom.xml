<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏湘伦的Blog</title>
  <subtitle>求知若渴，虚怀若谷</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://suxianglun.github.io/"/>
  <updated>2018-04-24T09:24:26.000Z</updated>
  <id>http://suxianglun.github.io/</id>
  
  <author>
    <name>苏湘伦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python中可变对象和不可变对象</title>
    <link href="http://suxianglun.github.io/2018/04/24/Python%E4%B8%AD%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/"/>
    <id>http://suxianglun.github.io/2018/04/24/Python中可变对象和不可变对象/</id>
    <published>2018-04-23T16:00:00.000Z</published>
    <updated>2018-04-24T09:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python中可变对象和不可变对象"><a href="#Python中可变对象和不可变对象" class="headerlink" title="Python中可变对象和不可变对象"></a>Python中可变对象和不可变对象</h3><p>python中对象可分为：可变对象和不可变对象<br>先从数据类型角度理解可变对象和不可变对象。  </p>
<p>抽象数据类型的操作一般分为三类：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1、构造操作:  这类操作主要是基于一些已知信息，产生这个类的实例对象。类似银行进行开通账户  </div><div class="line"> </div><div class="line">2、解析操作：这类操作是获取对象的一些有用信息，其结果反应了对象的一些特征，但返回的不是对象本身。类似银行查询账户余额   </div><div class="line"></div><div class="line">3、变化操作 ：这类操作是修改对象内部的信息和状态。比如一个银行账户进行转账操作</div><div class="line"></div><div class="line">如果一个类型，具只具有1和2两种操作，也就说只具有构造和解析操作，那么这个类型就是不可变类型，这个类型的对象就是不可变对象</div><div class="line">如果一个类型，具有1、2、3三种操作，这个类型就是可变类型，这个类型的对象就是可变对象。</div></pre></td></tr></table></figure>
<p><big>可变对象</big>：对象所指向的内存中的值不能被改变，当改变这个变量的时候，原来指向的内存中的值不变，变量不再指向原来的值，而是开辟一块新的内存，变量指向新的内存。<br>举个例子：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a=5</div><div class="line">&gt;&gt;&gt; print id(a)</div><div class="line">140433054259208</div><div class="line">&gt;&gt;&gt; a= 4</div><div class="line">&gt;&gt;&gt; print id(a)</div><div class="line">140433054259232</div><div class="line">&gt;&gt;&gt; print id(a),id(4)</div><div class="line">140433054259232 140433054259232</div><div class="line">&gt;&gt;&gt; print id(a),id(5)</div><div class="line">140433054259232 140433054259208</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>打印的结果表明：不可变对象int的变量a改变后，未改变之前指向内存中5，改变后开辟一块新内存指向4<br>由于是不可变对象，变量对应内存的值不允许被改变。当变量要改变时，实际上是把原来的值复制一份后再改变，开辟一个新的地址，astr再指向这个新的地址（所以前后astr的id不一样），原来astr对应的值因为不再有对象指向它,就会被垃圾回收。</p>
<p>再来看一下字符串str</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a=&apos;hello&apos;</div><div class="line">&gt;&gt;&gt; print id(a)</div><div class="line">4385118896</div><div class="line">&gt;&gt;&gt; a =a +&apos; world&apos;</div><div class="line">&gt;&gt;&gt; print a</div><div class="line">hello world</div><div class="line">&gt;&gt;&gt; print id(a)</div><div class="line">4385119040</div></pre></td></tr></table></figure>
<p>结果是一样的，也是开辟新内存，指向新内存中的值   </p>
<p><big>不可变对象</big>：对象指向的内存中的值会改变，当更改这个变量的时候，还是指向原来内存中的值，并且在原来的内存值进行原地修改，并没有开辟新的内存。      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; list=[1,2,3,4]</div><div class="line">&gt;&gt;&gt; print id(list)</div><div class="line">4384947808</div><div class="line">&gt;&gt;&gt; list[2]=5</div><div class="line">&gt;&gt;&gt; print list</div><div class="line">[1, 2, 5, 4]</div><div class="line">&gt;&gt;&gt; print id(list)</div><div class="line">4384947808</div></pre></td></tr></table></figure>
<p>结果表明: 列表list在改变前后id并未发生改变，可变对象由于所指对象可以被修改，所以无需复制一份之后再改变，直接原地改变，所以不会开辟新的内存，改变前后id不变。   </p>
<font size="3" color="red" face="“黑体”">在Python中，数值类型int 、float、 字符串str 、元祖tuple、boole 都是不可变对象<br>列表list、集合set、字典dict都是可变对象</font>   


<p>-</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Python中可变对象和不可变对象&quot;&gt;&lt;a href=&quot;#Python中可变对象和不可变对象&quot; class=&quot;headerlink&quot; title=&quot;Python中可变对象和不可变对象&quot;&gt;&lt;/a&gt;Python中可变对象和不可变对象&lt;/h3&gt;&lt;p&gt;python中对象可
    
    </summary>
    
      <category term="Python" scheme="http://suxianglun.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://suxianglun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java中Synchronized的用法</title>
    <link href="http://suxianglun.github.io/2018/03/07/Java%E4%B8%ADSynchronized%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://suxianglun.github.io/2018/03/07/Java中Synchronized的用法/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2018-03-08T02:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文 ：<a href="http://blog.csdn.net/luoweifu/article/details/46613015" target="_blank" rel="external">http://blog.csdn.net/luoweifu/article/details/46613015</a></p>
<h3 id="Java中Synchronized的用法"><a href="#Java中Synchronized的用法" class="headerlink" title="Java中Synchronized的用法"></a>Java中Synchronized的用法</h3><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<p>-</p>
<h4 id="修饰一个代码块"><a href="#修饰一个代码块" class="headerlink" title="修饰一个代码块"></a>修饰一个代码块</h4><p>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。我们看下面一个例子：</p>
<big><strong>Demo1:</strong></big>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 同步线程</div><div class="line"> */</div><div class="line">class SyncThread implements Runnable &#123;</div><div class="line">   private static int count;</div><div class="line"></div><div class="line">   public SyncThread() &#123;</div><div class="line">      count = 0;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public  void run() &#123;</div><div class="line">      synchronized(this) &#123;</div><div class="line">         for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            try &#123;</div><div class="line">               System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</div><div class="line">               Thread.sleep(100);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public int getCount() &#123;</div><div class="line">      return count;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SyncThread的调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SyncThread syncThread = new SyncThread();</div><div class="line">Thread thread1 = new Thread(syncThread, &quot;SyncThread1&quot;);</div><div class="line">Thread thread2 = new Thread(syncThread, &quot;SyncThread2&quot;);</div><div class="line">thread1.start();</div><div class="line">thread2.start();</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<blockquote>
<p>SyncThread1:0<br>SyncThread1:1<br>SyncThread1:2<br>SyncThread1:3<br>SyncThread1:4<br>SyncThread2:5<br>SyncThread2:6<br>SyncThread2:7<br>SyncThread2:8<br>SyncThread2:9</p>
</blockquote>
<p>当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。<br>我们再把SyncThread的调用稍微改一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Thread thread1 = new Thread(new SyncThread(), &quot;SyncThread1&quot;);</div><div class="line">Thread thread2 = new Thread(new SyncThread(), &quot;SyncThread2&quot;);</div><div class="line">thread1.start();</div><div class="line">thread2.start();</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<blockquote>
<p>SyncThread1:0<br>SyncThread2:1<br>SyncThread1:2<br>SyncThread2:3<br>SyncThread1:4<br>SyncThread2:5<br>SyncThread2:6<br>SyncThread1:7<br>SyncThread1:8<br>SyncThread2:9    </p>
</blockquote>
<p>不是说一个线程执行synchronized代码块时其它的线程受阻塞吗？为什么上面的例子中thread1和thread2同时在执行。这是因为synchronized只锁定对象，每个对象只有一个锁（lock）与之相关联，而上面的代码等同于下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SyncThread syncThread1 = new SyncThread();</div><div class="line">SyncThread syncThread2 = new SyncThread();</div><div class="line">Thread thread1 = new Thread(syncThread1, &quot;SyncThread1&quot;);</div><div class="line">Thread thread2 = new Thread(syncThread2, &quot;SyncThread2&quot;);</div><div class="line">thread1.start();</div><div class="line">thread2.start();</div></pre></td></tr></table></figure>
<p>这时创建了两个SyncThread的对象syncThread1和syncThread2，线程thread1执行的是syncThread1对象中的synchronized代码(run)，而线程thread2执行的是syncThread2对象中的synchronized代码(run)；我们知道synchronized锁定的是对象，这时会有两把锁分别锁定syncThread1对象和syncThread2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。    </p>
<p>-</p>
<p>2.当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。  </p>
<big> <strong>Demo2：多个线程访问synchronized和非synchronized代码块</strong> </big>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">class Counter implements Runnable&#123;</div><div class="line">   private int count;</div><div class="line"></div><div class="line">   public Counter() &#123;</div><div class="line">      count = 0;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void countAdd() &#123;</div><div class="line">      synchronized(this) &#123;</div><div class="line">         for (int i = 0; i &lt; 5; i ++) &#123;</div><div class="line">            try &#123;</div><div class="line">               System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</div><div class="line">               Thread.sleep(100);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //非synchronized代码块，未对count进行读写操作，所以可以不用synchronized</div><div class="line">   public void printCount() &#123;</div><div class="line">      for (int i = 0; i &lt; 5; i ++) &#123;</div><div class="line">         try &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot; count:&quot; + count);</div><div class="line">            Thread.sleep(100);</div><div class="line">         &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void run() &#123;</div><div class="line">      String threadName = Thread.currentThread().getName();</div><div class="line">      if (threadName.equals(&quot;A&quot;)) &#123;</div><div class="line">         countAdd();</div><div class="line">      &#125; else if (threadName.equals(&quot;B&quot;)) &#123;</div><div class="line">         printCount();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Counter counter = new Counter();</div><div class="line">Thread thread1 = new Thread(counter, &quot;A&quot;);</div><div class="line">Thread thread2 = new Thread(counter, &quot;B&quot;);</div><div class="line">thread1.start();</div><div class="line">thread2.start();</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<blockquote>
<p>A:0<br>B count:1<br>A:1<br>B count:2<br>A:2<br>B count:3<br>A:3<br>B count:4<br>A:4<br>B count:5   </p>
</blockquote>
<p>上面代码中countAdd是一个synchronized的，printCount是非synchronized的。从上面的结果中可以看出一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。</p>
<p>指定要给某个对象加锁</p>
<big><strong>【Demo3】:指定要给某个对象加锁</strong></big>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 银行账户类</div><div class="line"> */</div><div class="line">class Account &#123;</div><div class="line">   String name;</div><div class="line">   float amount;</div><div class="line"></div><div class="line">   public Account(String name, float amount) &#123;</div><div class="line">      this.name = name;</div><div class="line">      this.amount = amount;</div><div class="line">   &#125;</div><div class="line">   //存钱</div><div class="line">   public  void deposit(float amt) &#123;</div><div class="line">      amount += amt;</div><div class="line">      try &#123;</div><div class="line">         Thread.sleep(100);</div><div class="line">      &#125; catch (InterruptedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   //取钱</div><div class="line">   public  void withdraw(float amt) &#123;</div><div class="line">      amount -= amt;</div><div class="line">      try &#123;</div><div class="line">         Thread.sleep(100);</div><div class="line">      &#125; catch (InterruptedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public float getBalance() &#123;</div><div class="line">      return amount;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 账户操作类</div><div class="line"> */</div><div class="line">class AccountOperator implements Runnable&#123;</div><div class="line">   private Account account;</div><div class="line">   public AccountOperator(Account account) &#123;</div><div class="line">      this.account = account;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void run() &#123;</div><div class="line">      synchronized (account) &#123;</div><div class="line">         account.deposit(500);</div><div class="line">         account.withdraw(500);</div><div class="line">         System.out.println(Thread.currentThread().getName() + &quot;:&quot; + account.getBalance());</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Account account = new Account(&quot;zhang san&quot;, 10000.0f);</div><div class="line">AccountOperator accountOperator = new AccountOperator(account);</div><div class="line"></div><div class="line">final int THREAD_NUM = 5;</div><div class="line">Thread threads[] = new Thread[THREAD_NUM];</div><div class="line">for (int i = 0; i &lt; THREAD_NUM; i ++) &#123;</div><div class="line">   threads[i] = new Thread(accountOperator, &quot;Thread&quot; + i);</div><div class="line">   threads[i].start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<blockquote>
<p>Thread3:10000.0<br>Thread2:10000.0<br>Thread1:10000.0<br>Thread4:10000.0<br>Thread0:10000.0  </p>
</blockquote>
<p>在AccountOperator 类中的run方法里，我们用synchronized 给account对象加了锁。这时，当一个线程访问account对象时，其他试图访问account对象的线程将会阻塞，直到该线程访问account对象结束。也就是说谁拿到那个锁谁就可以运行它所控制的那段代码。<br>当有一个明确的对象作为锁时，就可以用类似下面这样的方式写程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void method3(SomeObject obj)</div><div class="line">&#123;</div><div class="line">   //obj 锁定的对象</div><div class="line">   synchronized(obj)</div><div class="line">   &#123;</div><div class="line">      // todo</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Test implements Runnable</div><div class="line">&#123;</div><div class="line">   private byte[] lock = new byte[0];  // 特殊的instance变量</div><div class="line">   public void method()</div><div class="line">   &#123;</div><div class="line">      synchronized(lock) &#123;</div><div class="line">         // todo 同步代码块</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void run() &#123;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。</p>
<h4 id="修饰一个方法"><a href="#修饰一个方法" class="headerlink" title="修饰一个方法"></a>修饰一个方法</h4><p>Synchronized修饰一个方法很简单，就是在方法的前面加synchronized，public synchronized void method(){//todo}; synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。如将【Demo1】中的run方法改成如下的方式，实现的效果一样。</p>
<big><strong>【Demo4】：synchronized修饰一个方法</strong></big>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public synchronized void run() &#123;</div><div class="line">   for (int i = 0; i &lt; 5; i ++) &#123;</div><div class="line">      try &#123;</div><div class="line">         System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</div><div class="line">         Thread.sleep(100);</div><div class="line">      &#125; catch (InterruptedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Synchronized作用于整个方法的写法。 </p>
<p>写法一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public synchronized void method()</div><div class="line">&#123;</div><div class="line">   // todo</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写法二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void method()</div><div class="line">&#123;</div><div class="line">   synchronized(this) &#123;</div><div class="line">      // todo</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。</p>
<p>在用synchronized修饰方法时要注意以下几点： </p>
<ol>
<li>synchronized关键字不能继承。<br>虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下：<br>在子类方法中加上synchronized关键字</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Parent &#123;</div><div class="line">   public synchronized void method() &#123; &#125;</div><div class="line">&#125;</div><div class="line">class Child extends Parent &#123;</div><div class="line">   public synchronized void method() &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在子类方法中调用父类的同步方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Parent &#123;</div><div class="line">   public synchronized void method() &#123;   &#125;</div><div class="line">&#125;</div><div class="line">class Child extends Parent &#123;</div><div class="line">   public void method() &#123; super.method();   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.在定义接口方法时不能使用synchronized关键字。<br>2.构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。 </p>
<p>-</p>
<h4 id="修饰一个静态的方法"><a href="#修饰一个静态的方法" class="headerlink" title="修饰一个静态的方法"></a>修饰一个静态的方法</h4><p>Synchronized也可修饰一个静态方法，用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public synchronized static void method() &#123;</div><div class="line">   // todo</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。我们对Demo1进行一些修改如下：</p>
<big><strong>【Demo5】：synchronized修饰静态方法</strong></big>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 同步线程</div><div class="line"> */</div><div class="line">class SyncThread implements Runnable &#123;</div><div class="line">   private static int count;</div><div class="line"></div><div class="line">   public SyncThread() &#123;</div><div class="line">      count = 0;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public synchronized static void method() &#123;</div><div class="line">      for (int i = 0; i &lt; 5; i ++) &#123;</div><div class="line">         try &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</div><div class="line">            Thread.sleep(100);</div><div class="line">         &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public synchronized void run() &#123;</div><div class="line">      method();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SyncThread syncThread1 = new SyncThread();</div><div class="line">SyncThread syncThread2 = new SyncThread();</div><div class="line">Thread thread1 = new Thread(syncThread1, &quot;SyncThread1&quot;);</div><div class="line">Thread thread2 = new Thread(syncThread2, &quot;SyncThread2&quot;);</div><div class="line">thread1.start();</div><div class="line">thread2.start();</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p>&gt;<br>SyncThread1:0<br>SyncThread1:1<br>SyncThread1:2<br>SyncThread1:3<br>SyncThread1:4<br>SyncThread2:5<br>SyncThread2:6<br>SyncThread2:7<br>SyncThread2:8<br>SyncThread2:9 </p>
<p>syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与Demo1是不同的。</p>
<p>-</p>
<h4 id="修饰一个类"><a href="#修饰一个类" class="headerlink" title="修饰一个类"></a>修饰一个类</h4><p>Synchronized还可作用于一个类，用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class ClassName &#123;</div><div class="line">   public void method() &#123;</div><div class="line">      synchronized(ClassName.class) &#123;</div><div class="line">         // todo</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们把Demo5再作一些修改。  </p>
<big><strong>【Demo6】:修饰一个类</strong></big>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 同步线程</div><div class="line"> */</div><div class="line">class SyncThread implements Runnable &#123;</div><div class="line">   private static int count;</div><div class="line"></div><div class="line">   public SyncThread() &#123;</div><div class="line">      count = 0;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public static void method() &#123;</div><div class="line">      synchronized(SyncThread.class) &#123;</div><div class="line">         for (int i = 0; i &lt; 5; i ++) &#123;</div><div class="line">            try &#123;</div><div class="line">               System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</div><div class="line">               Thread.sleep(100);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public synchronized void run() &#123;</div><div class="line">      method();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其效果和【Demo5】是一样的，synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。</p>
<p>-<br>总结：<br>A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。<br>B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。<br>C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p>
<p>-</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文 ：&lt;a href=&quot;http://blog.csdn.net/luoweifu/article/details/46613015&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/luoweifu/article
    
    </summary>
    
      <category term="Java" scheme="http://suxianglun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://suxianglun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HTTP和HTTPS之间的区别</title>
    <link href="http://suxianglun.github.io/2018/01/29/HTTP%E5%92%8CHTTPS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://suxianglun.github.io/2018/01/29/HTTP和HTTPS之间的区别/</id>
    <published>2018-01-28T16:00:00.000Z</published>
    <updated>2018-03-07T07:53:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP和HTTPS之间的区别"><a href="#HTTP和HTTPS之间的区别" class="headerlink" title="HTTP和HTTPS之间的区别"></a>HTTP和HTTPS之间的区别</h3><h4 id="HTTP和HTTPS的定义"><a href="#HTTP和HTTPS的定义" class="headerlink" title="HTTP和HTTPS的定义"></a>HTTP和HTTPS的定义</h4><h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h5><p>HTTP:超文本传输协议，HTTP 使用请求/响应的过程，因此信息可在服务器间快速、轻松而且精确的进行传输，但它使用的是明文进行传输，不安全</p>
<h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><p>HTTPS:https使用的是具有安全性的SSL加密传输协议。HTTPS 在 HTTP 应用层的基础上使用安全套接字层作为子层。HTTPS = HTTP + SSL</p>
<h5 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h5><p>SSL:安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议。<br>SSL协议的三个特性</p>
<p>Ø  保密：在握手协议中定义了会话密钥后，所有的消息都被加密。</p>
<p>Ø  鉴别：可选的客户端认证，和强制的服务器端认证。</p>
<p>Ø  完整性：传送的消息包括消息完整性检查（使用MAC）。</p>
<h4 id="HTTP-和-HTTPS-的相同点"><a href="#HTTP-和-HTTPS-的相同点" class="headerlink" title="HTTP 和 HTTPS 的相同点"></a>HTTP 和 HTTPS 的相同点</h4><p>都是采用同一个基础的协议，作为 HTTP 或 HTTPS 客户端——浏览器，设立一个连接到 Web 服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。系统使用统一资源定位器 URI 模式，因此资源可以被唯一指定。</p>
<h4 id="HTTP-和-HTTPS-的不同之处"><a href="#HTTP-和-HTTPS-的不同之处" class="headerlink" title="HTTP 和 HTTPS 的不同之处"></a>HTTP 和 HTTPS 的不同之处</h4><p>1、HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头<br>2、HTTP 是不安全的，而 HTTPS 是安全的<br>3、HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443<br>4、在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层<br>5、HTTP 无需加密，而 HTTPS 对传输的数据进行加密<br>6、HTTP 无需证书，而 HTTPS 需要认证证书</p>
<h4 id="HTTPS-如何工作"><a href="#HTTPS-如何工作" class="headerlink" title="HTTPS 如何工作?"></a>HTTPS 如何工作?</h4><p>使用 HTTPS 连接时，服务器要求有公钥和签名的证书。</p>
<p>当使用 https 连接，服务器响应初始连接，并提供它所支持的加密方法。作为回应，客户端选择一个连接方法，并且客户端和服务器端交换证书验证彼此身份。完成之后，在确保使用相同密钥的情况下传输加密信息，然后关闭连接。为了提供 https 连接支持，服务器必须有一个公钥证书，该证书包含经过证书机构认证的密钥信息，大部分证书都是通过第三方机构授权的，以保证证书是安全的。</p>
<p>换句话说，HTTPS 跟 HTTP 一样，只不过增加了 SSL。</p>
<p>HTTP 包含如下动作：</p>
<p>浏览器打开一个 TCP 连接<br>浏览器发送 HTTP 请求到服务器端<br>服务器发送 HTTP 回应信息到浏览器<br>TCP 连接关闭</p>
<p>SSL 包含如下动作：</p>
<p>验证服务器端<br>允许客户端和服务器端选择加密算法和密码，确保双方都支持<br>验证客户端(可选)<br>使用公钥加密技术来生成共享加密数据<br>创建一个加密的 SSL 连接<br>基于该 SSL 连接传递 HTTP 请求</p>
<h4 id="什么时候该使用-HTTPS"><a href="#什么时候该使用-HTTPS" class="headerlink" title="什么时候该使用 HTTPS?"></a>什么时候该使用 HTTPS?</h4><p>银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应该使用 HTTPS</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTTP和HTTPS之间的区别&quot;&gt;&lt;a href=&quot;#HTTP和HTTPS之间的区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP和HTTPS之间的区别&quot;&gt;&lt;/a&gt;HTTP和HTTPS之间的区别&lt;/h3&gt;&lt;h4 id=&quot;HTTP和HTTPS的定义
    
    </summary>
    
      <category term="Web" scheme="http://suxianglun.github.io/categories/Web/"/>
    
    
      <category term="Web" scheme="http://suxianglun.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Android使用gradle自动获取svn版本号</title>
    <link href="http://suxianglun.github.io/2018/01/29/Android%E4%BD%BF%E7%94%A8gradle%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96svn%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <id>http://suxianglun.github.io/2018/01/29/Android使用gradle自动获取svn版本号/</id>
    <published>2018-01-28T16:00:00.000Z</published>
    <updated>2018-01-30T03:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android使用gradle自动获取svn版本号"><a href="#Android使用gradle自动获取svn版本号" class="headerlink" title="Android使用gradle自动获取svn版本号"></a>Android使用gradle自动获取svn版本号</h3><p>由于我们公司项目在内网开发版本控制使用的是svn,为了方便测试同学提bug,以及开发同学及时定位bug，需要自动获取svn版本号。亲测有效，</p>
<h4 id="1、Project层下的-build-gradle-文件-引入svn插件"><a href="#1、Project层下的-build-gradle-文件-引入svn插件" class="headerlink" title="1、Project层下的  build.gradle  文件  引入svn插件"></a>1、Project层下的 <em> build.gradle </em> 文件  引入svn插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">classpath group: &apos;org.tmatesoft.svnkit&apos;, name: &apos;svnkit&apos;, version: &apos;1.8.11&apos;</div></pre></td></tr></table></figure>
<p>在我的项目中如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:3.0.0&apos;</div><div class="line">        classpath group: &apos;org.tmatesoft.svnkit&apos;, name: &apos;svnkit&apos;, version: &apos;1.8.11&apos;</div><div class="line">        // NOTE: Do not place your application dependencies here; they belong</div><div class="line">        // in the individual module build.gradle files</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2、Module层下的-build-gradle-文件加入以下两个步骤中内容："><a href="#2、Module层下的-build-gradle-文件加入以下两个步骤中内容：" class="headerlink" title="2、Module层下的  build.gradle  文件加入以下两个步骤中内容："></a>2、Module层下的 <strong> build.gradle </strong> 文件加入以下两个步骤中内容：</h4><h5 id="2-1、在文件第一行导包"><a href="#2-1、在文件第一行导包" class="headerlink" title="2.1、在文件第一行导包"></a>2.1、在文件第一行导包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import org.tmatesoft.svn.core.wc.*</div></pre></td></tr></table></figure>
<h5 id="2-2、定义函数"><a href="#2-2、定义函数" class="headerlink" title="2.2、定义函数"></a>2.2、定义函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def getSvnRevision() &#123;</div><div class="line">    ISVNOptions options = SVNWCUtil.createDefaultOptions(true);</div><div class="line">    SVNClientManager clientManager = SVNClientManager.newInstance(options);</div><div class="line">    SVNStatusClient statusClient = clientManager.getStatusClient();</div><div class="line">    SVNStatus status = statusClient.doStatus(projectDir, false);</div><div class="line">    SVNRevision revision = status.getCommittedRevision();</div><div class="line">    return revision.getNumber();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在我的项目中整体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import org.tmatesoft.svn.core.wc.*</div><div class="line"></div><div class="line">apply plugin: &apos;com.android.application&apos;</div><div class="line"></div><div class="line">//通过svnKit自动获取svn版本号</div><div class="line">def getSvnRevision() &#123;</div><div class="line">    ISVNOptions options = SVNWCUtil.createDefaultOptions(true)</div><div class="line">    SVNClientManager clientManager = SVNClientManager.newInstance(options)</div><div class="line">    SVNStatusClient statusClient = clientManager.getStatusClient()</div><div class="line">    SVNStatus status = statusClient.doStatus(projectDir, false)</div><div class="line">    SVNRevision revision = status.getCommittedRevision()</div><div class="line">    return revision.getNumber()</div><div class="line">&#125;</div><div class="line">android &#123;</div><div class="line">    compileSdkVersion 23</div><div class="line">    buildToolsVersion &apos;26.0.2&apos;</div><div class="line"></div><div class="line">    aaptOptions.cruncherEnabled = false</div><div class="line">    aaptOptions.useNewCruncher = false</div><div class="line">    lintOptions &#123;</div><div class="line">        abortOnError false</div><div class="line">    &#125;</div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId &quot;com.citicbank.comb&quot;</div><div class="line">        minSdkVersion 15</div><div class="line">        targetSdkVersion 16</div><div class="line">        versionCode  2</div><div class="line">        versionName &quot;$&#123;getSvnRevision()&#125;&quot; //调用方法获取svn版本号</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="3、java代码中获取svn版本号"><a href="#3、java代码中获取svn版本号" class="headerlink" title="3、java代码中获取svn版本号"></a>3、java代码中获取svn版本号</h4><p>主要是通过PackageManager获取PackageInfo,从而获取svn版本号，在需要svn版本号的地方，只需调用此方法即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static String getVersionName(Context context) &#123;</div><div class="line">        PackageManager packageManager = context.getPackageManager();</div><div class="line">        PackageInfo packInfo = null;</div><div class="line">        try &#123;</div><div class="line">            packInfo = packageManager.getPackageInfo(context.getPackageName(), 0);</div><div class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        String version = packInfo.versionName;</div><div class="line">        return version;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Android使用gradle自动获取svn版本号&quot;&gt;&lt;a href=&quot;#Android使用gradle自动获取svn版本号&quot; class=&quot;headerlink&quot; title=&quot;Android使用gradle自动获取svn版本号&quot;&gt;&lt;/a&gt;Android使用gr
    
    </summary>
    
      <category term="Android" scheme="http://suxianglun.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://suxianglun.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基础语法</title>
    <link href="http://suxianglun.github.io/2018/01/17/Kotlin%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://suxianglun.github.io/2018/01/17/Kotlin基础语法/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-22T09:37:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kotlin基础语法"><a href="#Kotlin基础语法" class="headerlink" title="Kotlin基础语法"></a>Kotlin基础语法</h3><h4 id="1、包声明"><a href="#1、包声明" class="headerlink" title="1、包声明"></a>1、包声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package com.citic.comb</div><div class="line"></div><div class="line">import android.os.Bundle</div><div class="line">import android.support.v7.app.AppCompatActivity</div><div class="line">import android.view.View</div><div class="line">import android.widget.Toast</div><div class="line">import kotlinx.android.synthetic.main.activity_main.*</div></pre></td></tr></table></figure>
<h4 id="2、变量定义"><a href="#2、变量定义" class="headerlink" title="2、变量定义"></a>2、变量定义</h4><p>可变变量定义：var 关键字</p>
<blockquote>
<p>var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</p>
</blockquote>
<p>不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量)</p>
<blockquote>
<p>val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</p>
</blockquote>
<p>栗子在下面👇</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">val str : String=&quot;你好&quot;</div><div class="line">var int : Int=2</div><div class="line">val b = 3 // 系统自动推断变量类型为Int</div><div class="line">var c :Int = 0</div></pre></td></tr></table></figure>
<h4 id="3、NULL检查机制："><a href="#3、NULL检查机制：" class="headerlink" title="3、NULL检查机制："></a>3、NULL检查机制：</h4><p>当某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空。这也是kotlin的特性 。Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//类型后面加?表示可为空</div><div class="line">var age: String? = &quot;23&quot; </div><div class="line"></div><div class="line">//抛出空指针异常</div><div class="line">val ages = age!!.toInt()</div><div class="line"></div><div class="line">//不做处理返回 null</div><div class="line">val ages1 = age?.toInt()</div><div class="line"></div><div class="line">//age为空返回-1</div><div class="line">val ages2 = age?.toInt() ?: -1</div></pre></td></tr></table></figure>
<p>当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。<br>当 str 中的字符串内容不是一个整数时, 返回 null:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun parseInt(str: String): Int? &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下实例演示如何使用一个返回值可为 null 的函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">  if (args.size &lt; 2) &#123;</div><div class="line">    print(&quot;Two integers expected&quot;)</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  val x = parseInt(args[0])</div><div class="line">  val y = parseInt(args[1])</div><div class="line">  // 直接使用 `x * y` 会导致错误, 因为它们可能为 null.</div><div class="line">  if (x != null &amp;&amp; y != null) &#123;</div><div class="line">    // 在进行过 null 值检查之后, x 和 y 的类型会被自动转换为非 null 变量</div><div class="line">    print(x * y)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4、类型检测及自动类型转换"><a href="#4、类型检测及自动类型转换" class="headerlink" title="4、类型检测及自动类型转换"></a>4、类型检测及自动类型转换</h4><p>我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">fun getStringLength(obj: Any): Int? &#123;</div><div class="line">  if (obj is String) &#123;</div><div class="line">    // 做过类型判断以后，obj会被系统自动转换为String类型</div><div class="line">    return obj.length </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //在这里还有一种方法，与Java中instanceof不同，使用!is</div><div class="line">  // if (obj !is String)&#123;</div><div class="line">  //   // XXX</div><div class="line">  // &#125;</div><div class="line"></div><div class="line">  // 这里的obj仍然是Any类型的引用</div><div class="line">  return null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun getStringLength(obj: Any): Int? &#123;</div><div class="line">  if (obj !is String)</div><div class="line">    return null</div><div class="line">  // 在这个分支中, `obj` 的类型会被自动转换为 `String`</div><div class="line">  return obj.length</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>甚至还可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun getStringLength(obj: Any): Int? &#123;</div><div class="line">  // 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String`</div><div class="line">  if (obj is String &amp;&amp; obj.length &gt; 0)</div><div class="line">    return obj.length</div><div class="line">  return null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5、函数定义"><a href="#5、函数定义" class="headerlink" title="5、函数定义"></a>5、函数定义</h4><p>函数定义使用关键字 fun，参数格式为：参数 : 类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun sum(a: Int, b: Int): Int &#123;   // Int 参数，返回值 Int</div><div class="line">    return a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>表达式作为函数体，返回类型自动推断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun sum(a: Int, b: Int) = a + b</div><div class="line"></div><div class="line">public fun sum(a: Int, b: Int): Int = a + b   // public 方法则必须明确写出返回类型</div></pre></td></tr></table></figure></p>
<p>无返回值的函数(类似Java中的void)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun printSum(a: Int, b: Int): Unit &#123; </div><div class="line">    print(a + b)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：</div><div class="line">public fun printSum(a: Int, b: Int) &#123; </div><div class="line">    print(a + b)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="可变长参数函数"><a href="#可变长参数函数" class="headerlink" title="可变长参数函数"></a>可变长参数函数</h5><p>函数的变长参数可以用 vararg 关键字进行标识：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fun vars(vararg v:Int)&#123;</div><div class="line">    for(vt in v)&#123;</div><div class="line">        print(vt)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    vars(1,2,3,4,5)  // 输出12345</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda(匿名函数)"></a>lambda(匿名函数)</h5><p>lambda表达式使用实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 测试</div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val sumLambda: (Int, Int) -&gt; Int = &#123;x,y -&gt; x+y&#125;</div><div class="line">    println(sumLambda(1,2))  // 输出 3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6、注释"><a href="#6、注释" class="headerlink" title="6、注释"></a>6、注释</h4><p>Kotlin 支持单行和多行注释，实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 这是一个单行注释</div><div class="line"></div><div class="line">/* 这是一个多行的</div><div class="line">   块注释。 */</div></pre></td></tr></table></figure>
<h4 id="7、字符串模板"><a href="#7、字符串模板" class="headerlink" title="7、字符串模板"></a>7、字符串模板</h4><p>$ 表示一个变量名或者变量值</p>
<p>$varName 表示变量值</p>
<p>${varName.fun()} 表示变量的方法返回值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 1</div><div class="line">// 模板中的简单名称：</div><div class="line">val s1 = &quot;a is $a&quot; </div><div class="line">print（s1）</div><div class="line"></div><div class="line">a = 2</div><div class="line">// 模板中的任意表达式：</div><div class="line">val s2 = &quot;$&#123;s1.replace(&quot;is&quot;, &quot;was&quot;)&#125;, but now is $a&quot;</div><div class="line">print（s2）</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>a is 1<br>a was 1 ,but now is 2</p>
</blockquote>
<h4 id="8、区间"><a href="#8、区间" class="headerlink" title="8、区间"></a>8、区间</h4><p>区间表达式由具有操作符形式 .. 的 rangeTo 函数辅以 in 和 !in 形成。</p>
<p>区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">for (i in 1..4) print(i) // 输出“1234”</div><div class="line"></div><div class="line">for (i in 4..1) print(i) // 什么都不输出</div><div class="line"></div><div class="line">if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10</div><div class="line">    println(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用 step 指定步长</div><div class="line">for (i in 1..4 step 2) print(i) // 输出“13”</div><div class="line"></div><div class="line">for (i in 4 downTo 1 step 2) print(i) // 输出“42”</div><div class="line"></div><div class="line"></div><div class="line">// 使用 until 函数排除结束元素</div><div class="line">for (i in 1 until 10) &#123;   // i in [1, 10) 排除了 10</div><div class="line">     println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实例测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    print(&quot;循环输出：&quot;)</div><div class="line">    for (i in 1..4) print(i) // 输出“1234”</div><div class="line">    println(&quot;\n----------------&quot;)</div><div class="line">    print(&quot;设置步长：&quot;)</div><div class="line">    for (i in 1..4 step 2) print(i) // 输出“13”</div><div class="line">    println(&quot;\n----------------&quot;)</div><div class="line">    print(&quot;使用 downTo：&quot;)</div><div class="line">    for (i in 4 downTo 1 step 2) print(i) // 输出“42”</div><div class="line">    println(&quot;\n----------------&quot;)</div><div class="line">    print(&quot;使用 until：&quot;)</div><div class="line">    // 使用 until 函数排除结束元素</div><div class="line">    for (i in 1 until 4) &#123;   // i in [1, 4) 排除了 4</div><div class="line">        print(i)</div><div class="line">    &#125;</div><div class="line">    println(&quot;\n----------------&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">循环输出：1234</div><div class="line">----------------</div><div class="line">设置步长：13</div><div class="line">----------------</div><div class="line">使用 downTo：42</div><div class="line">----------------</div><div class="line">使用 until：123</div><div class="line">----------------</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Kotlin基础语法&quot;&gt;&lt;a href=&quot;#Kotlin基础语法&quot; class=&quot;headerlink&quot; title=&quot;Kotlin基础语法&quot;&gt;&lt;/a&gt;Kotlin基础语法&lt;/h3&gt;&lt;h4 id=&quot;1、包声明&quot;&gt;&lt;a href=&quot;#1、包声明&quot; class=&quot;he
    
    </summary>
    
      <category term="Kotlin" scheme="http://suxianglun.github.io/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://suxianglun.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件之Service</title>
    <link href="http://suxianglun.github.io/2017/11/07/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BService/"/>
    <id>http://suxianglun.github.io/2017/11/07/Android四大组件之Service/</id>
    <published>2017-11-07T14:53:12.000Z</published>
    <updated>2017-11-28T12:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android四大组件之Service（1）"><a href="#Android四大组件之Service（1）" class="headerlink" title="Android四大组件之Service（1）"></a>Android四大组件之Service（1）</h3><h4 id="1、Service概念、作用及特点"><a href="#1、Service概念、作用及特点" class="headerlink" title="1、Service概念、作用及特点"></a>1、Service概念、作用及特点</h4><p>先看一下源码里对Service的解释    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">* A Service is an application component representing either an application&apos;s desire</div><div class="line"> * to perform a longer-running operation while not interacting with the user</div><div class="line"> * or to supply functionality for other applications to use.  Each service</div><div class="line"> * class must have a corresponding</div><div class="line"> * &#123;@link android.R.styleable#AndroidManifestService &amp;lt;service&amp;gt;&#125;</div><div class="line"> * declaration in its package&apos;s &lt;code&gt;AndroidManifest.xml&lt;/code&gt;.  Services</div><div class="line"> * can be started with</div><div class="line"> * &#123;@link android.content.Context#startService Context.startService()&#125; and</div><div class="line"> * &#123;@link android.content.Context#bindService Context.bindService()&#125;.</div><div class="line"> * </div><div class="line"> * &lt;p&gt;Note that services, like other application objects, run in the main</div><div class="line"> * thread of their hosting process.  This means that, if your service is going</div><div class="line"> * to do any CPU intensive (such as MP3 playback) or blocking (such as</div><div class="line"> * networking) operations, it should spawn its own thread in which to do that</div><div class="line"> * work.  More information on this can be found in</div><div class="line"> * &lt;a href=&quot;&#123;@docRoot&#125;guide/topics/fundamentals/processes-and-threads.html&quot;&gt;Processes and</div><div class="line"> * Threads&lt;/a&gt;.  The &#123;@link IntentService&#125; class is available</div><div class="line"> * as a standard implementation of Service that has its own thread where it</div><div class="line"> * schedules its work to be done.&lt;/p&gt;</div></pre></td></tr></table></figure>
<p>从上边看出以下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">概念：服务为Android四大组件之一   </div><div class="line">作用：提供在后台需要长期运行的服务（如复杂计算、下载等等）</div><div class="line">运行地方：在主线程中</div><div class="line">注意事项：使用前必须在AndroidManifest.xml注册，如果要进行长期的运行需要自己的线程，即新建一个线程，也可以使用标准的IntentService。</div><div class="line">启动方式：startService()和bindService()</div><div class="line">特点：长生命周期的、没有用户界面、在后台运行</div></pre></td></tr></table></figure>
<h4 id="2、Service分类、各自特点及应用场景"><a href="#2、Service分类、各自特点及应用场景" class="headerlink" title="2、Service分类、各自特点及应用场景"></a>2、Service分类、各自特点及应用场景</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/944365-8855e3a5340bece5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Service分类" title="">
                </div>
                <div class="image-caption">Service分类</div>
            </figure>
<h4 id="3、Service与Thread的区别："><a href="#3、Service与Thread的区别：" class="headerlink" title="3、Service与Thread的区别："></a>3、Service与Thread的区别：</h4><p>应该说Service和Thread没有任何联系，唯一相同点就是执行异步操作，由于Service有后台的概念，很容易将其和Thread混为一谈。一般来说，会将Service和Thread联合着用，即在Service中再创建一个子线程（工作线程）去处理耗时操作逻辑.     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override  </div><div class="line">public int onStartCommand(Intent intent, int flags, int startId) &#123;  </div><div class="line">//新建工作线程</div><div class="line">    new Thread(new Runnable() &#123;  </div><div class="line">        @Override  </div><div class="line">        public void run() &#123;  </div><div class="line">            // 开始执行后台任务  </div><div class="line">        &#125;  </div><div class="line">    &#125;).start();  </div><div class="line">    return super.onStartCommand(intent, flags, startId);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后台的定义：后台任务运行完全不依赖UI，即使Activity被销毁，或者程序被关闭，只要进程还在，后台任务就可以继续运行  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/944365-384170261e06ecbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="4、Service生命周期"><a href="#4、Service生命周期" class="headerlink" title="4、Service生命周期"></a>4、Service生命周期</h4><p>手动调用的方法：</p>
<table>
<thead>
<tr>
<th>手动调用的方法</th>
<th>作用</th>
<th>自动调用的内部方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>startService()</td>
<td>启动服务</td>
<td>onCreate()、onStartCommand()</td>
</tr>
<tr>
<td>stopService()</td>
<td>停止服务</td>
<td>onDestroy()</td>
</tr>
<tr>
<td>bindService()</td>
<td>绑定服务</td>
<td>onCreate()、onBind()</td>
</tr>
<tr>
<td>unbindService()</td>
<td>解绑服务</td>
<td>onUnBind()、 onDestroy()</td>
</tr>
</tbody>
</table>
<p>内部自动调用的方法：</p>
<table>
<thead>
<tr>
<th>内部自动调用的方法</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>onCreate()</td>
<td>创建服务</td>
<td>首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。</td>
</tr>
<tr>
<td>onStartCommand()</td>
<td>开始服务</td>
<td>当另外一个组件（Activity）使用startService()启动服务的时候调用此方法。onStartCommmand()调用次数==启动次数，一旦执行此方法，服务即会启动并可在后台无限期运行。</td>
</tr>
<tr>
<td>onBind()</td>
<td>绑定服务</td>
<td>当另一个组件通过bindService()绑定服务时，系统会调用此方法，</td>
</tr>
<tr>
<td>onUnBind()</td>
<td>解绑服务</td>
<td>调用</td>
</tr>
<tr>
<td>onDestroy()</td>
<td>销毁服务</td>
<td>当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。    </td>
</tr>
</tbody>
</table>
<h4 id="Service-两种形式"><a href="#Service-两种形式" class="headerlink" title="Service 两种形式"></a>Service 两种形式</h4><ul>
<li><big><font color="blue">启动状态</font></big><br>当应用组件（例如Activity）通过startService（）启动服务后，Service就处于启动状态，就会一直运行下去，除非手动调用stopServiec()</li>
<li><big><font color="blue">绑定状态</font></big><br>与启动服务不同的是绑定服务的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说宿主(如Activity)解除绑定后，绑定服务就会被销毁</li>
</ul>
<p>此文章参考以下出处：<br><a href="http://blog.csdn.net/javazejian/article/details/52709857" target="_blank" rel="external">http://blog.csdn.net/javazejian/article/details/52709857</a><br><a href="http://www.jianshu.com/p/d963c55c3ab9/" target="_blank" rel="external">http://www.jianshu.com/p/d963c55c3ab9/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Android四大组件之Service（1）&quot;&gt;&lt;a href=&quot;#Android四大组件之Service（1）&quot; class=&quot;headerlink&quot; title=&quot;Android四大组件之Service（1）&quot;&gt;&lt;/a&gt;Android四大组件之Service（
    
    </summary>
    
      <category term="Android" scheme="http://suxianglun.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://suxianglun.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件之Activity</title>
    <link href="http://suxianglun.github.io/2017/11/03/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity%20%20/"/>
    <id>http://suxianglun.github.io/2017/11/03/Android四大组件之Activity  /</id>
    <published>2017-11-03T03:23:02.000Z</published>
    <updated>2017-11-06T08:05:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android四大组件之Activity"><a href="#Android四大组件之Activity" class="headerlink" title="Android四大组件之Activity"></a>Android四大组件之Activity</h3><h4 id="1、Activity生命周期"><a href="#1、Activity生命周期" class="headerlink" title="1、Activity生命周期"></a>1、Activity生命周期</h4><p>一般情况下Activity会经历如下生命周期：<br>为了方便先上一下官方的Activity生命周期图解</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.bdqn.cn/upload/2013/12/10/7841386643107.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>（1）onCreate()：</strong> 表示activity正在被创建，是activity的第一个生命周期，在这期间进行页面的初始化，setContenView()加载页面布局资源、初始化一些变量等工作。</p>
<p><strong>（2）onStart()：</strong> 表示activity正在启动，这个时候已经可见，但是还未出现在前台，不能和用户进行交互。这个时候activity已经出来了但我们看不到。</p>
<p><strong>（3）onResume()：</strong> 表示activity已经可见了，位于前台了，可以和用户进行交互。和onStart的相同点和区别：onStart和onResume时期Activity都已可见，但onStart不在前台，不能与用户进行交互，而onResume已在前台，可以和用户进行交互。</p>
<p><strong>（4）onPause()：</strong> 表示activity正在暂停，正常情况下紧接着就执行onStop,这期间可以进行一些动画停止、数据存储工作。但不能耗时，否则会影响新activity的启动。因为启动新activity时，执行onPause()后就会执行新Activity的onCreate</p>
<p><strong>（5）onStop()：</strong> 表示activity即将停止，这期间可以做一些重量级的回收工作。但不能太耗时</p>
<p><strong>（6）onDestroy()：</strong> 表示activity即将被销毁，这是activity最后一个生命周期，这期间可以做一些回收工作和资源回收。</p>
<p><strong>（7）onRestart()：</strong> 表示activity重新启动，即从不可见状态变为可见状态时就会被调用，一般情况下都是用户操作才会调用，例如用户操作Home键或者启动一个新页面，旧页面会执行onPause和onStop，然后再回到旧页面，这时就会调用onRestart，然后再调用onStart和onResume</p>
<h4 id="2、Activity启动模式"><a href="#2、Activity启动模式" class="headerlink" title="2、Activity启动模式"></a>2、Activity启动模式</h4><ul>
<li><p>2.1、<strong>standard</strong>  Activity默认的启动模式，每次启动Activity都会创建一个新的实例，放入任务栈中。这是一个典型的多实例，每一个任务栈可以有多个Activity，每个Activity可以属于多个任务栈。哪个Activity启动了当前Activity，当前Activity就放入改Activity所在的任务栈。比如<br>Activity A启动了Activity B，那么Activity B就位于Activity A所在的任务栈中。此模式下onCreate()、onStart()、onResume()都会执行。<br><img src="http://upload-images.jianshu.io/upload_images/1865963-95632974ce6906ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">   </p>
</li>
<li><p>2.2、<strong>singleTop</strong> 栈顶复用模式，启动的Activity位于栈顶时则会通过调用onNewItent()方法复用原来的Activity，不再创建一个新的实例。否则会像standard模式那样。一句话概述就是：<strong>当且仅当启动的 Activity 和上一个 Activity 一致的时候才会通过调用 onNewIntent() 方法重用 Activity</strong> 。使用场景：资讯阅读类 APP 的内容界面。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/1865963-ba7ce60bc7c5024c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">
                </div>
                <div class="image-caption">image.png</div>
            </figure>
</li>
</ul>
<ul>
<li>2.3 <strong>singleTask</strong> 栈内复用模式，当启动的Activity位于栈内时，就会通过调用onNewItent()方法复用当前的Activity，如果当前Activity上面还有其他Activity，同时会将其他Activity从栈内移出。如果栈内不存在当前Activity，则和standard模式一样。即： A -&gt;B -&gt; C -&gt; D -&gt; B，此时栈内变成了  A -&gt; B。而 A -&gt; B -&gt; C，栈内还是 A -&gt; B -&gt; C。使用场景：浏览器的主页面，或者大部分 APP 的主页面。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/1865963-5b4d620903d03f94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">
                </div>
                <div class="image-caption">image.png</div>
            </figure>
<ul>
<li>2.4 <strong>singleInstance</strong> 单实例模式，是一个加强版的singleTask，除了拥有singleTask的特性外，此种模式下Activity单独在一个任务栈中，依然是调用 onNewIntent() 方法。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/1865963-445b30b1ea2d746a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">
                </div>
                <div class="image-caption">image.png</div>
            </figure>
</li>
</ul>
<p>到这里Activity启动模式就要说完了，其实还有一点与其相联系的知识，那就是<strong>Inent标签</strong><br>在 Android 中，我们除了在清单文件 AndroidManifest.xml 中配置 launchMode，当然可以用 Intent 标签说事儿。启动 Activity ，我们需要传递一个 Intent，完全可以通过设置 Intent.setFlags(int flags) 来设置启动的 Activity 的启动模式。</p>
<p>需要注意的是：通过代码来设置 Activity 的启动模式的方式，优先级比清单文件设置更高。</p>
<p>FLAG_ACTIVITY_NEW_TASK<br>这个标识会使新启动的 Activity 独立创建一个 Task。</p>
<p>FLAG_ACTIVITY_CLEAR_TOP<br>这个标识会使新启动的 Activity 检查是否存在于 Task 中，如果存在则清除其之上的 Activity，使它获得焦点，并不重新实例化一个 Activity，一般结合 FLAG_ACTIVITY_NEW_TASK 一起使用。</p>
<p>FLAG_ACTIVITY_SINGLE_TOP<br>等同于在 launcherMode 属性设置为 singleTop。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Android四大组件之Activity&quot;&gt;&lt;a href=&quot;#Android四大组件之Activity&quot; class=&quot;headerlink&quot; title=&quot;Android四大组件之Activity&quot;&gt;&lt;/a&gt;Android四大组件之Activity&lt;/h3&gt;&lt;
    
    </summary>
    
      <category term="Android" scheme="http://suxianglun.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://suxianglun.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android消息机制</title>
    <link href="http://suxianglun.github.io/2017/10/30/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://suxianglun.github.io/2017/10/30/Android消息机制/</id>
    <published>2017-10-30T03:15:04.000Z</published>
    <updated>2017-10-30T05:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android消息机制"><a href="#Android消息机制" class="headerlink" title="Android消息机制"></a>Android消息机制</h3><p>读了《Android开发艺术探索》中Android消息机制后对Android消息机制有了一个更深的理解，Android<br>消息机制主要就是Handler运行机制。Handler运行机制需要MessageQueue、Looper来作为支撑。</p>
<h5 id="1、MessageQueue工作原理"><a href="#1、MessageQueue工作原理" class="headerlink" title="1、MessageQueue工作原理"></a>1、MessageQueue工作原理</h5><p>MessageQueue即消息队列，主要进行两个操作：插入消息和读取消息，分别对应的方法是enqueueMessage()和next(),读取消息伴随着删除操作。MessageQueue命名为消息队列，其实内部却是使用单向链表的数据结构来维护消息队列的，单向链表在数据的插入和删除效率较高，具有优势。enqueueMessage()方法内部是对单链表的操作，next()方法内部是一个死循环，如果消息队列中没有消息，就一直阻塞在那里。</p>
<h5 id="2、Looper工作原理"><a href="#2、Looper工作原理" class="headerlink" title="2、Looper工作原理"></a>2、Looper工作原理</h5><p>Looper 在消息机制中起到消息循环的作用，Looper.prepare()获得当前线程的Looper对象，然后再通过Looper.loop()开启消息循环。除了prepare（）方法，Looper.prepareMainLooper()方法可以获取主线程的Looper,当然此方法也是通过prepare（）来实现的。Looper.getMainLooper()可以在任何地方获取主线程的Looper对象。Looper还可以退出，通过quit()和quitSafely()，二者区别是quit()是直接退出，quitSafely（）是先设定一个退出标记，然后将消息队列的中已有的消息都处理完后再退出。<br>Looper退出后，Handler send消息时就会报错。Looper.loop()方法执行后才开启消息循环，loop（）方法是一个无限循环，直到MessageQueue.next()返回null时跳出循环。</p>
<h5 id="3、Handler工作原理"><a href="#3、Handler工作原理" class="headerlink" title="3、Handler工作原理"></a>3、Handler工作原理</h5><p>Handler主要就是进行消息的发送和接受，发送消息主要通过send的一系列方法和post的一系列方法，post方法也是通过send来实现的。Handler发送一条消息只是将该条数据插入Messagequeue中，Messagequeue的next()方法就会将这条消息返回给Looper,Looper收到消息后就开始处理了，最终Looper将消息交给Handler处理，即调用Handler的dispathMessage()。在dispathMessage()方法中先判断msg.callback是否为空，callback是一个Runnable对象，即handler的post()方法中Runnable,如果不为空就调用handleCallback()方法，然后在判断mCallback是否为空，不为空就调用mCallback的handleMessage()方法，mCallback是一个接口，创建Handler handler=new Handler（callback）时需要传一个callback。也就是说我们可以通过callback无须派生一个Handler子类就可以创建Handler，这样最终就调用handler的handMessage()方法。</p>
<h5 id="4、Handler使用说明"><a href="#4、Handler使用说明" class="headerlink" title="4、Handler使用说明"></a>4、Handler使用说明</h5><p>要想知道当前的Handler是哪个线程的Handler只需知道创建Handler时绑定的是哪个线程的Looper,如果创建的时候没有指定Looper，那就是主线程的Handler，因为只有主线程的Looper已经被获取，其他线程需要手动获取。还有一点就是，在哪个线程使用Handler的send或者post一系列方法，就是从当前Handler所在的线程给Handler本身所属的线程发消息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Android消息机制&quot;&gt;&lt;a href=&quot;#Android消息机制&quot; class=&quot;headerlink&quot; title=&quot;Android消息机制&quot;&gt;&lt;/a&gt;Android消息机制&lt;/h3&gt;&lt;p&gt;读了《Android开发艺术探索》中Android消息机制后对And
    
    </summary>
    
      <category term="Android" scheme="http://suxianglun.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://suxianglun.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>if __name__ == &quot;__main__&quot;:是干嘛的?</title>
    <link href="http://suxianglun.github.io/2017/08/16/name==main%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://suxianglun.github.io/2017/08/16/name==main的作用/</id>
    <published>2017-08-16T04:46:17.000Z</published>
    <updated>2017-08-16T04:46:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例先吟诗一首：</p>
<blockquote>
<blockquote>
<p>《宫词·故国三千里》–张祜<br>故国三千里，深宫二十年。<br>一声何满子，双泪落君前。</p>
</blockquote>
</blockquote>
<h4 id="if-name-“main“-是干嘛的"><a href="#if-name-“main“-是干嘛的" class="headerlink" title="if name == “main“:是干嘛的?"></a>if <strong>name</strong> == “<strong>main</strong>“:是干嘛的?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># Threading example</div><div class="line">import time, thread</div><div class="line"></div><div class="line">def myfunction(string, sleeptime, lock, *args):</div><div class="line">    while 1:</div><div class="line">        lock.acquire()</div><div class="line">        time.sleep(sleeptime)</div><div class="line">        lock.release()</div><div class="line">        time.sleep(sleeptime)</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    lock = thread.allocate_lock()</div><div class="line">    thread.start_new_thread(myfunction, (&quot;Thread #: 1&quot;, 2, lock))</div><div class="line">    thread.start_new_thread(myfunction, (&quot;Thread #: 2&quot;, 2, lock))</div></pre></td></tr></table></figure>
<p>当Python解析器读取一个源文件时,它会执行所有的代码.在执行代码前,会定义一些特殊的变量.例如,如果解析器运行的模块(源文件)作为主程序,它将会把<strong>name</strong>变量设置成”<strong>main</strong>“.如果只是引入其他的模块,<strong>name</strong>变量将会设置成模块的名字.</p>
<p>假设下面是你的脚本,让我们作为主程序来执行:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python threading_example.py</div></pre></td></tr></table></figure>
<p>当设置完特殊变量,它就会执行import语句并且加载这些模块.当遇到def代码段的时候,它就会创建一个函数对象并创建一个名叫myfunction变量指向函数对象.接下来会读取if语句并检查<strong>name</strong>是不是等于”<strong>main</strong>“,如果是的话他就会执行这个代码段.</p>
<p>这么做的原因是有时你需要你写的模块既可以直接的执行,还可以被当做模块导入到其他模块中去.通过检查是不是主函数,可以让你的代码只在它作为主程序运行时执行,而当其他人调用你的模块中的函数的时候不必执行.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例先吟诗一首：&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;《宫词·故国三千里》–张祜&lt;br&gt;故国三千里，深宫二十年。&lt;br&gt;一声何满子，双泪落君前。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;if-name
    
    </summary>
    
      <category term="Python" scheme="http://suxianglun.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://suxianglun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决Python2.7的UnicodeEncodeError异常错误</title>
    <link href="http://suxianglun.github.io/2017/08/16/%E8%A7%A3%E5%86%B3Python2.7UnicodeEncodeError%E5%BC%82%E5%B8%B8%E9%94%99%E8%AF%AF/"/>
    <id>http://suxianglun.github.io/2017/08/16/解决Python2.7UnicodeEncodeError异常错误/</id>
    <published>2017-08-16T04:37:55.000Z</published>
    <updated>2017-08-16T04:41:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例先吟诗一首:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">      芙蓉楼送辛渐  </div><div class="line">        </div><div class="line">     (唐代：王昌龄)   </div><div class="line">寒雨连江夜入吴，平明送客楚山孤。    </div><div class="line">洛阳亲友如相问，一片冰心在玉壶。</div></pre></td></tr></table></figure>
<h3 id="1、解决Python2-7的UnicodeEncodeError-‘ascii’-codec-can’t-encode异常错误"><a href="#1、解决Python2-7的UnicodeEncodeError-‘ascii’-codec-can’t-encode异常错误" class="headerlink" title="1、解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误"></a>1、解决Python2.7的UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误</h3><p>最近练习Python爬虫的时候遇到一个错误，先上解决错误前的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">   # coding:utf-8</div><div class="line">import urllib2</div><div class="line">import sysfrom bs4 import BeautifulSoup</div><div class="line">import uniout</div><div class="line">from quote import Quote</div><div class="line"></div><div class="line"></div><div class="line">class Xianqian:</div><div class="line">    def __init__(self):</div><div class="line">        self.url = &apos;http://www.juzimi.com/先秦&apos;</div><div class="line">        self.headers = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&apos;&#125;</div><div class="line"></div><div class="line">    def get_writer(self):</div><div class="line">        # reload(sys)</div><div class="line">        # sys.setdefaultencoding(&apos;utf-8&apos;)</div><div class="line">       </div><div class="line">        req = urllib2.Request(self.url, headers=self.headers, )</div><div class="line">        res = urllib2.urlopen(req)</div><div class="line">        soup = BeautifulSoup(res.read(), &apos;html.parser&apos;)</div><div class="line">        print soup</div></pre></td></tr></table></figure></p>
<h3 id="2、出现如下错误"><a href="#2、出现如下错误" class="headerlink" title="2、出现如下错误"></a>2、出现如下错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 14-15: ordinal not in range(128)</div></pre></td></tr></table></figure>
<h3 id="3、分析原因："><a href="#3、分析原因：" class="headerlink" title="3、分析原因："></a>3、分析原因：</h3><p>看了下异常信息，是因为编码问题：Unicode编码与ASCII编码的不兼容，其实这个Python脚本文件是由utf-8编码的,而Python默认环境编码是ascii编码方式，由此Python自然调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内，就会抛出异常（ordinal not in range(128)）。如果你不知道Python默认环境编码是什么，可以通过下面的方法可以获取:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">print sys.getdefaultencoding()</div><div class="line"># &apos;ascii&apos;</div></pre></td></tr></table></figure>
<h3 id="4、解决方案："><a href="#4、解决方案：" class="headerlink" title="4、解决方案："></a>4、解决方案：</h3><p>通过sys.setdefaultencoding(‘utf-8)设置Python默认环境编码为utf-8，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">sys.setdefaultencoding(‘utf-8)</div></pre></td></tr></table></figure>
<p>但是运行之后出现了如下错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AttributeError: &apos;module&apos; object has no attribute &apos;setdefaultencoding&apos;</div></pre></td></tr></table></figure>
<p>意思是说sys没有setdefaultencoding()这个方法，其实是有的，只不过是先需要reload(sys)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</div></pre></td></tr></table></figure>
<p>这样就可以正常运行了<br>修改后的代码如下: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">import urllib2</div><div class="line">import sys</div><div class="line">from bs4 import BeautifulSoup</div><div class="line">import uniout</div><div class="line">from quote import Quote</div><div class="line"></div><div class="line"></div><div class="line">class Xianqian:</div><div class="line">    def __init__(self):</div><div class="line">        self.url = &apos;http://www.juzimi.com/&apos;</div><div class="line">        self.headers = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64)&apos;&#125;</div><div class="line"></div><div class="line">    def get_writer(self):</div><div class="line">        reload(sys)</div><div class="line">        sys.setdefaultencoding(&apos;utf-8&apos;)</div><div class="line">        quote = Quote()</div><div class="line">        req = urllib2.Request(self.url, headers=self.headers)</div><div class="line">        res = urllib2.urlopen(req)</div><div class="line">        soup = BeautifulSoup(res.read(), &apos;html.parser&apos;)</div><div class="line">        print soup</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例先吟诗一首:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div 
    
    </summary>
    
      <category term="Python" scheme="http://suxianglun.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://suxianglun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python中range和xrange的区别</title>
    <link href="http://suxianglun.github.io/2017/07/24/python%E4%B8%ADrange%E5%92%8Cxrange%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://suxianglun.github.io/2017/07/24/python中range和xrange的区别/</id>
    <published>2017-07-24T06:26:20.000Z</published>
    <updated>2017-07-24T07:33:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例先吟诗一首：</p>
<blockquote>
<blockquote>
<p>《行宫》–元稹   </p>
<p>寥落古行宫，宫花寂寞红。<br>  白头宫女在，闲坐说玄宗。</p>
</blockquote>
</blockquote>
<h4 id="range-start-None-stop-None-step-None-函数说明："><a href="#range-start-None-stop-None-step-None-函数说明：" class="headerlink" title="range(start=None, stop=None, step=None)函数说明："></a>range(start=None, stop=None, step=None)函数说明：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Return a list containing an arithmetic progression of integers.     </div><div class="line">  	range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.</div><div class="line">    When step is given, it specifies the increment (or decrement).</div><div class="line">    For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!</div><div class="line">    These are exactly the valid indices for a list of 4 elements.</div></pre></td></tr></table></figure>
<p>大致意思就是：range函数返回的是包含一个等差数列的整数列表，根据参数start与stop指定的范围以及step设定的差值，生成一个列表。 如果不指定step默认差值就是1，如果指定step，它指定递增(或递减)，差值就是step.如果不明白举个栗子，如果还不明白就举2个栗子。    </p>
<p>例子1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=range(0,10,2)</div><div class="line">print a</div><div class="line">print type(a)</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[0, 2, 4, 6, 8]</div><div class="line">&lt;type &apos;list&apos;&gt;</div></pre></td></tr></table></figure>
<p>例子2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=range(0,-10,-2)</div><div class="line">print a</div><div class="line">print type(a)</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[0, -2, -4, -6, -8]</div><div class="line">&lt;type &apos;list&apos;&gt;</div></pre></td></tr></table></figure>
<h4 id="xrange-函数说明：和range-的用法完全相同，但是返回的是一个生成器。"><a href="#xrange-函数说明：和range-的用法完全相同，但是返回的是一个生成器。" class="headerlink" title="xrange 函数说明：和range 的用法完全相同，但是返回的是一个生成器。"></a>xrange 函数说明：和range 的用法完全相同，但是返回的是一个生成器。</h4><p>例子1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=xrange(0,10,2)</div><div class="line">print a</div><div class="line">print type(a)</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[xrange(0, 10, 2)</div><div class="line">&lt;type &apos;xrange&apos;&gt;</div></pre></td></tr></table></figure>
<p>例子2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=xrange(0,-10,-2)</div><div class="line">print a</div><div class="line">print type(a)</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xrange(0, -10, -2)</div><div class="line">&lt;type &apos;xrange&apos;&gt;</div></pre></td></tr></table></figure>
<h4 id="range和xrange区别："><a href="#range和xrange区别：" class="headerlink" title="range和xrange区别："></a>range和xrange区别：</h4><p>两个都是在循环迭代的时候使用，range返回的是个list,xrange返回的是xrange对象，生成很小的数字序列时候性能没什么区别，但是要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。如果你不是为了要返回一个list,在循环中尽量使用xrange。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例先吟诗一首：&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;《行宫》–元稹   &lt;/p&gt;
&lt;p&gt;寥落古行宫，宫花寂寞红。&lt;br&gt;  白头宫女在，闲坐说玄宗。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;rang
    
    </summary>
    
      <category term="Python" scheme="http://suxianglun.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://suxianglun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python PIL库安装</title>
    <link href="http://suxianglun.github.io/2017/07/05/Python%20pIL%E5%BA%93%E5%AE%89%E8%A3%85/"/>
    <id>http://suxianglun.github.io/2017/07/05/Python pIL库安装/</id>
    <published>2017-07-05T08:01:16.000Z</published>
    <updated>2017-07-25T06:31:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例先吟诗一首</p>
<blockquote>
<blockquote>
<p> 听筝<br>唐代：李端<br>鸣筝金粟柱，素手玉房前。<br>欲得周郎顾，时时误拂弦。</p>
</blockquote>
</blockquote>
<p>由于需要使用Python操作图片，想使用<strong>sudo pip install PIL</strong>引入PIL(Python Imaging Library)库，但是结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">could not find a version that satisfies the requirement PIL.(form versions:)</div><div class="line">No matching distribution found for PIL.</div></pre></td></tr></table></figure>
<p>这个提示很费解，只能去找度娘了，原来已经用Pillow代替了PIL，在使用方面没有不同，API都是相同的。真是个挨千刀的，提示信息里怎么不告诉我们这些刚学Python的小白呢，还得白忙活半天。既然这样那就老老实实安装Pillow吧。但是又发现Pillow需要依赖multiprocessing，所以必须先安装multiprocessing。命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install multiprocessing</div></pre></td></tr></table></figure>
<p>接着再执行如下命令：   </p>
<pre><code>sudo pip install Pillow
</code></pre><p>引入模块要按照下面的方式写（注意大小写）<br>第一种：from PIL import Image<br>第二种：from PIL.Image(用这种方式时，下面使用时也得写成PIL.Image.open(‘1.png’)，或者可以在引入时修改下模块名，如from PIL.Image as image)</p>
<p>引入之后就可以正常使用了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例先吟诗一首&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 听筝&lt;br&gt;唐代：李端&lt;br&gt;鸣筝金粟柱，素手玉房前。&lt;br&gt;欲得周郎顾，时时误拂弦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于需要使用Python操作
    
    </summary>
    
      <category term="Python" scheme="http://suxianglun.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://suxianglun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java线程常用方法之join()</title>
    <link href="http://suxianglun.github.io/2017/06/01/Java%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B9%8Bjoin()/"/>
    <id>http://suxianglun.github.io/2017/06/01/Java线程常用方法之join()/</id>
    <published>2017-06-01T08:10:06.000Z</published>
    <updated>2017-07-25T06:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例先吟诗一首：</p>
<blockquote>
<blockquote>
<p> 送崔九<br>唐代：裴迪<br>归山深浅去，须尽丘壑美。<br>莫学武陵人，暂游桃源里。</p>
</blockquote>
</blockquote>
<p>join()方法的作用是等待线程销毁。例如在main线程新起一个子线程，子线程需要做一些耗时造作，main线程想要得到子线程执行完成的数据，就必须等到执行完子线程再去执行，这时候就可以用join来解决。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>下面用代码来说明：    </p>
<p><strong>MyThread类</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class MyThread04 extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try&#123;</div><div class="line">            int value=(int)(Math.random()*1000);</div><div class="line">            System.out.println(&quot;thread04 value=&quot;+value);</div><div class="line">            Thread.sleep(value);</div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>YieldTest类</strong>     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class JoinTest &#123;</div><div class="line">    public  static void main(String[] args)&#123;</div><div class="line">        MyThread04 thread04=new MyThread04();</div><div class="line">        thread04.start();</div><div class="line">//        try &#123;</div><div class="line">//            thread04.join();</div><div class="line">//        &#125;catch (InterruptedException e)&#123;</div><div class="line">//            e.printStackTrace();</div><div class="line">//        &#125;</div><div class="line">        System.out.println(&quot;我想在thread04之后执行&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：     </p>
<blockquote>
<blockquote>
<p>我想在thread04之后执行<br>thread04 value=8</p>
</blockquote>
</blockquote>
<p>从结果上看，主线程和子线程是异步的，并没有在子线程执行完之后才执行，而是在子线程执行过程中就执行了主线程。如果想要实现同步的话，需要用到join()方法</p>
<p>将MyThread03类更改一下    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class JoinTest &#123;</div><div class="line">    public  static void main(String[] args)&#123;</div><div class="line">        MyThread04 thread04=new MyThread04();</div><div class="line">        thread04.start();</div><div class="line">        try &#123;</div><div class="line">            thread04.join();</div><div class="line">           </div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">		 System.out.println(&quot;我想在thread04之后执行&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：    </p>
<blockquote>
<blockquote>
<p>thread04 value=323<br>我想在thread04之后执行</p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例先吟诗一首：&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 送崔九&lt;br&gt;唐代：裴迪&lt;br&gt;归山深浅去，须尽丘壑美。&lt;br&gt;莫学武陵人，暂游桃源里。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;join()方法的作用是
    
    </summary>
    
      <category term="Java" scheme="http://suxianglun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://suxianglun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程常用方法之yield()</title>
    <link href="http://suxianglun.github.io/2017/06/01/Java%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B9%8Byield()/"/>
    <id>http://suxianglun.github.io/2017/06/01/Java线程常用方法之yield()/</id>
    <published>2017-06-01T07:41:19.000Z</published>
    <updated>2017-07-25T06:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例先吟诗一首：</p>
<blockquote>
<blockquote>
<p> 杂诗<br>唐代：王维<br>君自故乡来，应知故乡事。<br>来日绮窗前，寒梅著花未？</p>
</blockquote>
</blockquote>
<p>yield()方法的作用是让当前线程放弃当前cup资源，让其他任务获取cup资源。但放弃的时间不确定，有可能放放弃又马上获取cpu资源。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>下面用代码来说明：    </p>
<p><strong>MyThread类</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class MyThread03 extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        long beginTime=System.currentTimeMillis();</div><div class="line">        int count=0;</div><div class="line">        for (int i=0;i&lt;50000000;i++)&#123;</div><div class="line">//            Thread.yield();</div><div class="line">            count=count+(i+1);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        long endTime=System.currentTimeMillis();</div><div class="line">        System.out.println(&quot;用时=&quot;+(endTime-beginTime)+&quot;毫秒&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>YieldTest类</strong>     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class YieldTest &#123;</div><div class="line">    public  static void main(String[] args)&#123;</div><div class="line">        MyThread03 thread03=new MyThread03();</div><div class="line">        thread03.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：     </p>
<blockquote>
<blockquote>
<p>用时=23毫秒</p>
</blockquote>
</blockquote>
<p>将MyThread03类更改一下    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class MyThread03 extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        long beginTime=System.currentTimeMillis();</div><div class="line">        int count=0;</div><div class="line">        for (int i=0;i&lt;50000000;i++)&#123;</div><div class="line">            Thread.yield();</div><div class="line">            count=count+(i+1);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        long endTime=System.currentTimeMillis();</div><div class="line">        System.out.println(&quot;用时=&quot;+(endTime-beginTime)+&quot;毫秒&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：    </p>
<blockquote>
<blockquote>
<p>用时=10552毫秒</p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例先吟诗一首：&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 杂诗&lt;br&gt;唐代：王维&lt;br&gt;君自故乡来，应知故乡事。&lt;br&gt;来日绮窗前，寒梅著花未？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;yield()方法的作用是
    
    </summary>
    
      <category term="Java" scheme="http://suxianglun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://suxianglun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程常用方法之sleep()</title>
    <link href="http://suxianglun.github.io/2017/06/01/Java%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B9%8Bsleep()%20/"/>
    <id>http://suxianglun.github.io/2017/06/01/Java线程常用方法之sleep() /</id>
    <published>2017-06-01T07:25:55.000Z</published>
    <updated>2017-07-25T06:28:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例先吟诗一首：</p>
<blockquote>
<blockquote>
<p> 山中送别<br>唐代：王维<br>山中相送罢，<br>日暮掩柴扉。<br>春草明年绿，<br>王孙归不归？</p>
</blockquote>
</blockquote>
<p>sleep()方法的作用是在指定的毫秒数中让当前运行的线程休眠，当前的线程指的是this.currentTread() </p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>下面用代码来说明：    </p>
<p><strong>MyThread类</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class  MyThread02 extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;Thread name:&quot;+Thread.currentThread().getName()+&quot;begin=&quot;+System.currentTimeMillis());</div><div class="line">            Thread.sleep(2000);</div><div class="line">            System.out.println(&quot;Thread name:&quot;+Thread.currentThread().getName()+&quot;end=&quot;+System.currentTimeMillis());</div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>SleepTest类</strong>     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class SleepTest &#123;</div><div class="line">    public  static void main(String[] args)&#123;</div><div class="line">        MyThread02 thread02=new MyThread02();</div><div class="line">        System.out.println(&quot;Begin&quot;);</div><div class="line">        thread02.start();</div><div class="line">        System.out.println(&quot;end&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：     </p>
<blockquote>
<blockquote>
<p>Begin<br>end<br>Thread name:Thread-0begin=1496281723821<br>Thread name:Thread-0end=1496281725822   </p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例先吟诗一首：&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 山中送别&lt;br&gt;唐代：王维&lt;br&gt;山中相送罢，&lt;br&gt;日暮掩柴扉。&lt;br&gt;春草明年绿，&lt;br&gt;王孙归不归？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;sle
    
    </summary>
    
      <category term="Java" scheme="http://suxianglun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://suxianglun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程常用方法之isAlive()</title>
    <link href="http://suxianglun.github.io/2017/05/27/Java%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B9%8BisAlive()/"/>
    <id>http://suxianglun.github.io/2017/05/27/Java线程常用方法之isAlive()/</id>
    <published>2017-05-27T08:49:30.000Z</published>
    <updated>2017-07-24T07:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例先吟诗一首：</p>
<blockquote>
<blockquote>
<p>《春怨 / 伊州歌》<br>唐代：金昌绪<br>打起黄莺儿，莫教枝上啼。<br>啼时惊妾梦，不得到辽西。</p>
</blockquote>
</blockquote>
<p>这篇主要来了解一下isAlive()方法，此方法返回当前线程是否处于“活动状态”，何为“活动状态”，线程已经启动尚未终止。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>下面用代码来说明：    </p>
<p><strong>MyThread类</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class MyThread01 extends Thread&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;Name:&quot;+Thread.currentThread().getName());</div><div class="line">        System.out.println(&quot;state:&quot;+Thread.currentThread().isAlive());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>IsAliveTest类</strong>     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class IsAliveTest &#123;</div><div class="line">    public static void main(String [] args)&#123;</div><div class="line">        MyThread01 thread01=new MyThread01();</div><div class="line">        System.out.println(&quot;begin:&quot;+thread01.isAlive());</div><div class="line">        thread01.start();</div><div class="line">        System.out.println(&quot;end:&quot;+thread01.isAlive());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：     </p>
<blockquote>
<blockquote>
<p>begin:false<br>end:true<br>Name:Thread-0<br>state:true </p>
</blockquote>
</blockquote>
<p>将IsAliveTest类改为如下：     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class IsAliveTest &#123;</div><div class="line">    public static void main(String [] args)&#123;</div><div class="line">        MyThread01 thread01=new MyThread01();</div><div class="line">        System.out.println(&quot;begin:&quot;+thread01.isAlive());</div><div class="line">        thread01.start();</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;end:&quot;+thread01.isAlive());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<blockquote>
<blockquote>
<p>begin:false<br>Name:Thread-0<br>state:true<br>end:false</p>
</blockquote>
</blockquote>
<p>调用Thread.sleep(1000)让主线程休眠1秒，在这1秒内Thread-0线程已经执行完毕，再调用isAlive()时返回false</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例先吟诗一首：&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;《春怨 / 伊州歌》&lt;br&gt;唐代：金昌绪&lt;br&gt;打起黄莺儿，莫教枝上啼。&lt;br&gt;啼时惊妾梦，不得到辽西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇主要来
    
    </summary>
    
      <category term="Java" scheme="http://suxianglun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://suxianglun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程常用方法之currentThread（）</title>
    <link href="http://suxianglun.github.io/2017/05/27/Java%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B9%8BcurrentThread()/"/>
    <id>http://suxianglun.github.io/2017/05/27/Java线程常用方法之currentThread()/</id>
    <published>2017-05-27T08:35:30.000Z</published>
    <updated>2017-05-27T08:42:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java线程中有很多常用的方法，需要花费一些时间来理解，今天就先来学习一下currentThread（）方法。<br>currentThread（）方法返回调用此代码段的线程信息，其中可以通过     Thread.currentThread().getId()获取当前线程id<br>Thread.currentThread().getName()获取当前线程name<br>Thread.currentThread().getPriority()获取当前线程优先级     </p>
<p>下面用代码来说明：    </p>
<p><strong>MyThread类</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class MyThread extends Thread&#123;</div><div class="line">    public  MyThread()&#123;</div><div class="line">        System.out.println(&quot;构造方法中打印的线程名字：&quot;+Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;run方法中打印的线程名字：&quot;+Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>CurrentThreadTest类</strong>     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CurrentThreadTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[ ]args)&#123;</div><div class="line">        Thread thread=new MyThread();</div><div class="line">        thread.start();</div><div class="line">//        thread.run();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：     </p>
<blockquote>
<blockquote>
<p>构造方法中打印的线程名字：main<br>run方法中打印的线程名字：Thread-0  </p>
</blockquote>
</blockquote>
<p>说明MyThread类的构造方法被main线程调用的，run方法是自动调用的方法。</p>
<p>将CurrentThreadTest类改为如下：     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CurrentThreadTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[ ]args)&#123;</div><div class="line">        Thread thread=new MyThread();</div><div class="line">//        thread.start();</div><div class="line">        thread.run();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<blockquote>
<blockquote>
<p>构造方法中打印的线程名字：main<br>run方法中打印的线程名字：main     </p>
</blockquote>
</blockquote>
<p>说明MyThread类的构造方法被main线程调用的，run方法是被main线程调用的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java线程中有很多常用的方法，需要花费一些时间来理解，今天就先来学习一下currentThread（）方法。&lt;br&gt;currentThread（）方法返回调用此代码段的线程信息，其中可以通过     Thread.currentThread().getId()获取当前线程
    
    </summary>
    
      <category term="Java" scheme="http://suxianglun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://suxianglun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程的五种状态</title>
    <link href="http://suxianglun.github.io/2017/05/26/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%20/"/>
    <id>http://suxianglun.github.io/2017/05/26/Java线程的状态 /</id>
    <published>2017-05-26T09:34:36.000Z</published>
    <updated>2017-07-25T06:27:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例先吟诗一首：</p>
<blockquote>
<blockquote>
<p> 送上人<br>唐代：刘长卿<br>孤云将野鹤，岂向人间住。<br>莫买沃洲山，时人已知处。</p>
</blockquote>
</blockquote>
<h4 id="什么是线程："><a href="#什么是线程：" class="headerlink" title="什么是线程："></a>什么是线程：</h4><p>一个线程是进程的一个顺序执行流。同类的多个线程共享一块内存空间和一组系统资源，一个进程中可以包含多个线程。    </p>
<h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><p>一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="http://pdf7.tarena.com.cn/tts8_source/ttsPage/JAVA/JSD_N_V06/JAVASE02/DAY04/SUPERDOC/01/index.files/image001.png" alt=""></p>
<h5 id="新建状态"><a href="#新建状态" class="headerlink" title="新建状态"></a>新建状态</h5><p>当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。</p>
<h5 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h5><p>个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。</p>
<p>处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序来调度的。</p>
<h5 id="运行状态（Running）"><a href="#运行状态（Running）" class="headerlink" title="运行状态（Running）"></a>运行状态（Running）</h5><p>当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法。</p>
<h5 id="阻塞状态（blocked）"><a href="#阻塞状态（blocked）" class="headerlink" title="阻塞状态（blocked）"></a>阻塞状态（blocked）</h5><p>线程运行过程中，可能由于各种原因进入阻塞状态：</p>
<p>①线程通过调用sleep方法进入睡眠状态；</p>
<p>②线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；</p>
<p>③线程试图得到一个锁，而该锁正被其他线程持有；</p>
<p>④线程在等待某个触发条件；</p>
<p>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。</p>
<h5 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h5><p>有两个原因会导致线程死亡：</p>
<p>①run方法正常退出而自然死亡；</p>
<p>②一个未捕获的异常终止了run方法而使线程猝死；</p>
<p>为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法，如果是可运行或被阻塞，这个方法返回true；如果线程仍旧是new状态且不是可运行的，或者线程死亡了，则返回false。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例先吟诗一首：&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 送上人&lt;br&gt;唐代：刘长卿&lt;br&gt;孤云将野鹤，岂向人间住。&lt;br&gt;莫买沃洲山，时人已知处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;什么是线程：
    
    </summary>
    
      <category term="Java" scheme="http://suxianglun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://suxianglun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中val 和var的区别</title>
    <link href="http://suxianglun.github.io/2017/05/24/Kotlin%E4%B8%ADval%20%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://suxianglun.github.io/2017/05/24/Kotlin中val 和var的区别/</id>
    <published>2017-05-24T07:25:28.000Z</published>
    <updated>2017-07-25T06:30:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例先吟诗一首</p>
<blockquote>
<blockquote>
<p> 静夜思<br>唐代：李白<br>床前明月光，疑是地上霜。<br>举头望明月，低头思故乡。</p>
</blockquote>
</blockquote>
<p>前几天朋友圈刷爆了关于Kotlin成为Android官方语言的新闻，为了体验一下，开始学习Kotlin的基础语法。其中Kotlin中有两个关键字定义变量var和val,区别如下：    </p>
<p><strong>var：</strong> var是一个可变变量，这是一个可以通过重新分配来更改为另一个值的变量。这种声明变量的方式和Java中声明变量的方式一样。<br><strong>val:</strong>  val是一个只读变量，这种声明变量的方式相当于java中的final变量。一个val创建的时候必须初始化，因为以后不能被改变。</p>
<p>上段代码体验一下：</p>
<pre><code>var name = &quot;lao wang&quot;
println(name)
name = &quot;xiao wang&quot;
println(name)
val finalValue = &quot;我万年不变的老李&quot;;
println(finalValue);
</code></pre><p>结果如下：</p>
<blockquote>
<p>lao wang<br>xiao wang<br>我万年不变的老李</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例先吟诗一首&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; 静夜思&lt;br&gt;唐代：李白&lt;br&gt;床前明月光，疑是地上霜。&lt;br&gt;举头望明月，低头思故乡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;前几天朋友圈刷爆了关于Ko
    
    </summary>
    
      <category term="Kotlin" scheme="http://suxianglun.github.io/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://suxianglun.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>flask_restful安装遇到的问题</title>
    <link href="http://suxianglun.github.io/2017/05/15/%E5%AE%89%E8%A3%85%20Flask-RESTful%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://suxianglun.github.io/2017/05/15/安装 Flask-RESTful遇到的问题/</id>
    <published>2017-05-15T09:40:16.000Z</published>
    <updated>2017-07-24T07:44:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例先吟诗一首：</p>
<blockquote>
<blockquote>
<p>《登乐游原》–李商隐<br>向晚意不适，驱车登古原。<br>夕阳无限好，只是近黄昏。</p>
</blockquote>
</blockquote>
<h4 id="1-使用-pip-安装-Flask-RESTful"><a href="#1-使用-pip-安装-Flask-RESTful" class="headerlink" title="1.使用 pip 安装 Flask-RESTful:"></a>1.使用 pip 安装 Flask-RESTful:</h4><blockquote>
<p>pip install flask-restful</p>
</blockquote>
<p>使用pip安装第三方库总是提示：You are using pip version 8.0.2, however version 8.1.0 is available</p>
<p>且输入“python -m pip install -U pip”升级pip版本命名还是报同样的错误。 </p>
<p><strong>解决办法：</strong><br>  <strong>第一步：</strong>使用PyCharm，选择file→Setting，找到pip 双击<br>  <img src="http://www.chenxm.cc/zb_users/upload/2016/07/201607221469181275894919.jpg" alt="">     </p>
<p>  <strong>第二步：</strong>按照图片，点击pip，勾选specify version，然后点击 install package<br>  <img src="http://www.chenxm.cc/zb_users/upload/2016/07/201607221469181275770256.jpg" alt=""></p>
<p>  <strong>第三步：</strong>如果安装出现连接不成功，请使用VPN；<br>  如果出现报错：“UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xd7 in position 9: ordinal not in range(128)”请修改mimetypes.py文件，路径位于python的安装路径下的Lib\mimetypes.py文件。在import下添加如下几行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if sys.getdefaultencoding() != &apos;gbk&apos;:</div><div class="line">    reload(sys)</div><div class="line">    sys.setdefaultencoding(&apos;gbk&apos;)</div></pre></td></tr></table></figure>
<p> 然后重复第二步操作，安装即可。</p>
<p><strong>注意：</strong><br>其实也可以直接执行第三步，直接修改mimetypes.py文件的信息，然后输入pip升级命令“python -m pip install -U pip”     </p>
<h4 id="2-安装过程中遇到的第二个问题："><a href="#2-安装过程中遇到的第二个问题：" class="headerlink" title="2.安装过程中遇到的第二个问题："></a>2.安装过程中遇到的第二个问题：</h4><p>Permission denied: ‘/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/dateutil’  </p>
<p>这里是因为权限问题，需要使用sudo安装，键入如下代码安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install flask-restful</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例先吟诗一首：&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;《登乐游原》–李商隐&lt;br&gt;向晚意不适，驱车登古原。&lt;br&gt;夕阳无限好，只是近黄昏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-使用-pip-安
    
    </summary>
    
      <category term="Python" scheme="http://suxianglun.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://suxianglun.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
